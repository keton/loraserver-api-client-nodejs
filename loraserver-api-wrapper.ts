import * as API from "./api";
import http from 'http';

class Util {
	/**
	* Helper function that formats http.ClientResponse|any error object into readable message
	* 
	* @param error error object returned by autogenerated API
	* @param msg formatted error message prefix
	* @param func function to call with formatted error string as parameter, typically reject()
	*/
	public static formatError = (error: any, msg: string, func: Function) => {
		if (error.response && error.response.statusCode && error.response.statusMessage) {
			var err = <{ response: http.ClientResponse; body: any; }>error;
			func(msg + " error " + err.response.statusCode + ": " + err.response.statusMessage);
		} else {
			func(error);
		}
	}
}

class InternalApi {
	private loraServerApi: LoraServerApi;
	private internalApi: API.InternalServiceApi;

	constructor(loraServerApi: LoraServerApi) {
		this.loraServerApi = loraServerApi;
		this.internalApi = new API.InternalServiceApi(loraServerApi.basePath);
		this.internalApi.setDefaultAuthentication(loraServerApi.apiKey);
	}

	/**
	 * Login to server and obtain bearer token for use with APIs that require authentication
	 * 
	 * @param user Username
	 * @param password Password
	 */
	public login = async (user: string, password: string) => {
		return new Promise<void>(async (resolve, reject) => {
			try {
				var resp = await this.internalApi.login({
					username: user,
					password: password
				});
				this.loraServerApi.apiKey.apiKey = resp.body.jwt;
				resolve();

			} catch (error) {
				Util.formatError(error, "InternalApi.login()", reject);
			}
		});
	}

	/**
	 * Get branding for the UI
	 */
	public branding = async () => {
		return new Promise<API.ApiBrandingResponse>(async (resolve, reject) => {
			try {
				var ret = await this.internalApi.branding();
				resolve(ret.body);
			} catch (error) {
				Util.formatError(error, "InternalApi.branding()", reject);
			}
		});
	}

	/**
	 * Get current user's profile
	 */
	public profile = async() => {
		return new Promise<API.ApiProfileResponse>(async (resolve, reject) => {
			try {
				var ret = await this.internalApi.profile();
				resolve(ret.body);
			} catch (error) {
				Util.formatError(error, "InternalApi.profile()", reject);
			}
		});
	}

	/**
	 * Perform global search
	 * 
	 * @param options.limit Max items per query (pagination)
	 * @param options.offset Skip this many results (pagination)
	 * @param options.search Search string
	 */
	public search = async (options?: { limit?: number, offset?: number, search?: string }) => {

		var limit = "1000";
		var offset: string | undefined = undefined;
		var search: string | undefined = undefined;

		if (options) {
			if (options.limit) limit = options.limit.toString();
			if (options.offset) offset = options.offset.toString();
			if (options.search) search = options.search;
		}

		return new Promise<API.ApiGlobalSearchResult[]>(async (resolve, reject) => {
			try {
				var res = await this.internalApi.globalSearch(search,limit,offset);
				resolve(res.body.result);
			} catch (error) {
				Util.formatError(error, "InternalApi.search()", reject);
			}
		});
	}
}

class ApplicationsAPI {
	private applicationsApi: API.ApplicationServiceApi;

	constructor(loraServerApi: LoraServerApi) {
		this.applicationsApi = new API.ApplicationServiceApi(loraServerApi.basePath);
		this.applicationsApi.setDefaultAuthentication(loraServerApi.apiKey);
	}

	/**
	 * Get list of applications meeting search criteria
	 * @param options.limit Max items per query (pagination)
	 * @param options.offset Skip this many results (pagination)
	 * @param options.organizationId Limit search to given organization
	 * @param options.search Search string to match against application name
	 */
	public list = async (options?: { limit?: number, offset?: number, organizationId?: string, search?: string }) => {

		var limit = "1000";
		var offset: string | undefined = undefined;
		var organizationId: string | undefined = undefined;
		var search: string | undefined = undefined;

		if (options) {
			if (options.limit) limit = options.limit.toString();
			if (options.offset) offset = options.offset.toString();
			if (options.organizationId) organizationId = options.organizationId;
			if (options.search) search = options.search;
		}

		return new Promise<API.ApiApplicationListItem[]>(async (resolve, reject) => {
			try {
				var res = await this.applicationsApi.list(limit, offset, organizationId, search);
				resolve(res.body.result);
			} catch (error) {
				Util.formatError(error, "ApplicationsAPI.list()", reject);
			}
		});
	}
}

class DeviceServiceAPI {
	private deviceServiceApi: API.DeviceServiceApi;

	constructor(loraServerApi: LoraServerApi) {
		this.deviceServiceApi = new API.DeviceServiceApi(loraServerApi.basePath);
		this.deviceServiceApi.setDefaultAuthentication(loraServerApi.apiKey);
	}

	/**
	 * Get list of devices meeting search criteria
	 * 
	 * @param options.limit Max items per query (pagination)
	 * @param options.offset Skip this many results (pagination)
	 * @param options.applicationID Limit search to given application
	 * @param options.multicastGroupID Limit search to given multicast group
	 * @param options.serviceProfileID Limit search to given service profile
	 */
	public list = async (options: { limit?: number, offset?: number, applicationID?: string, search?: string, multicastGroupID?: string, serviceProfileID?: string }) => {

		var limit = "1000";
		var offset: string | undefined = undefined;
		var applicationID: string | undefined = undefined;
		var search: string | undefined = undefined;
		var multicastGroupID: string | undefined = undefined;
		var serviceProfileID: string | undefined = undefined;

		if (options) {
			if (options.limit) limit = options.limit.toString();
			if (options.applicationID) applicationID = options.applicationID;
			if (options.search) search = options.search;
			if (options.multicastGroupID) multicastGroupID = options.multicastGroupID;
			if (options.serviceProfileID) serviceProfileID = options.serviceProfileID;
		}

		return new Promise<API.ApiDeviceListItem[]>(async (resolve, reject) => {
			try {
				var res = await this.deviceServiceApi.list(limit, offset, applicationID, search, multicastGroupID, serviceProfileID);
				resolve(res.body.result);
			} catch (error) {
				Util.formatError(error, "DeviceServiceAPI.list()", reject);
			}
		});
	}
}

export default class LoraServerApi {

	readonly basePath: string;

	//bearer token API key
	readonly apiKey: API.ApiKeyAuth = new API.ApiKeyAuth("header", "Grpc-Metadata-Authorization");

	//API subclasses
	public internal: InternalApi;
	public applications: ApplicationsAPI;
	public devices: DeviceServiceAPI;

	/**
	 * Class constructor
	 * 
	 * @param basePath Server URL (i.e. https://localhost:8080)
	 */
	constructor(basePath: string) {
		this.basePath = basePath;
		this.internal = new InternalApi(this);
		this.applications = new ApplicationsAPI(this);
		this.devices = new DeviceServiceAPI(this);
	}

	/**
	 * Shortcut for internal.login()
	 */
	public login = (user: string, password: string) => {
		return this.internal.login(user, password);
	}
}