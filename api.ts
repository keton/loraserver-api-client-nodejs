/**
 * LoRa App Server REST API
 *  For more information about the usage of the LoRa App Server (REST) API, see [https://docs.loraserver.io/lora-app-server/api/](https://docs.loraserver.io/lora-app-server/api/). 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest from 'request';
import http from 'http';

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class ApiActivateDeviceRequest {
    'deviceActivation': ApiDeviceActivation;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceActivation",
            "baseName": "deviceActivation",
            "type": "ApiDeviceActivation"
        }    ];

    static getAttributeTypeMap() {
        return ApiActivateDeviceRequest.attributeTypeMap;
    }
}

export class ApiAddDeviceToMulticastGroupRequest {
    /**
    * Device EUI (HEX encoded string). Note that the device must be under the same service-profile as the multicast-group.
    */
    'devEUI': string;
    /**
    * Multicast-group ID (string formatted UUID).
    */
    'multicastGroupID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "devEUI",
            "baseName": "devEUI",
            "type": "string"
        },
        {
            "name": "multicastGroupID",
            "baseName": "multicastGroupID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiAddDeviceToMulticastGroupRequest.attributeTypeMap;
    }
}

export class ApiAddOrganizationUserRequest {
    /**
    * Organization-user object to create.
    */
    'organizationUser': ApiOrganizationUser;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationUser",
            "baseName": "organizationUser",
            "type": "ApiOrganizationUser"
        }    ];

    static getAttributeTypeMap() {
        return ApiAddOrganizationUserRequest.attributeTypeMap;
    }
}

export class ApiApplication {
    /**
    * Description of the application.
    */
    'description': string;
    /**
    * Application ID. This will be automatically assigned on create.
    */
    'id': string;
    /**
    * Name of the application (must be unique).
    */
    'name': string;
    /**
    * ID of the organization to which the application belongs.
    */
    'organizationID': string;
    /**
    * Payload codec.
    */
    'payloadCodec': string;
    /**
    * Payload decoder script.
    */
    'payloadDecoderScript': string;
    /**
    * Payload encoder script.
    */
    'payloadEncoderScript': string;
    /**
    * ID of the service profile.
    */
    'serviceProfileID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "payloadCodec",
            "baseName": "payloadCodec",
            "type": "string"
        },
        {
            "name": "payloadDecoderScript",
            "baseName": "payloadDecoderScript",
            "type": "string"
        },
        {
            "name": "payloadEncoderScript",
            "baseName": "payloadEncoderScript",
            "type": "string"
        },
        {
            "name": "serviceProfileID",
            "baseName": "serviceProfileID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiApplication.attributeTypeMap;
    }
}

export class ApiApplicationListItem {
    /**
    * Description of the application.
    */
    'description': string;
    /**
    * Application ID.
    */
    'id': string;
    /**
    * Name of the application.
    */
    'name': string;
    /**
    * ID of the organization to which the application belongs.
    */
    'organizationID': string;
    /**
    * ID of the service profile.
    */
    'serviceProfileID': string;
    /**
    * Service-profile name.
    */
    'serviceProfileName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "serviceProfileID",
            "baseName": "serviceProfileID",
            "type": "string"
        },
        {
            "name": "serviceProfileName",
            "baseName": "serviceProfileName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiApplicationListItem.attributeTypeMap;
    }
}

export class ApiBrandingResponse {
    /**
    * Footer html.
    */
    'footer': string;
    /**
    * Logo html.
    */
    'logo': string;
    /**
    * Registration html.
    */
    'registration': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "logo",
            "baseName": "logo",
            "type": "string"
        },
        {
            "name": "registration",
            "baseName": "registration",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiBrandingResponse.attributeTypeMap;
    }
}

export class ApiCreateApplicationRequest {
    /**
    * Application object to create.
    */
    'application': ApiApplication;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "application",
            "baseName": "application",
            "type": "ApiApplication"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateApplicationRequest.attributeTypeMap;
    }
}

export class ApiCreateApplicationResponse {
    /**
    * Application ID.
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateApplicationResponse.attributeTypeMap;
    }
}

export class ApiCreateDeviceKeysRequest {
    /**
    * Device-keys object to create.
    */
    'deviceKeys': ApiDeviceKeys;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceKeys",
            "baseName": "deviceKeys",
            "type": "ApiDeviceKeys"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateDeviceKeysRequest.attributeTypeMap;
    }
}

export class ApiCreateDeviceProfileRequest {
    /**
    * Device-profile object to create.
    */
    'deviceProfile': ApiDeviceProfile;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceProfile",
            "baseName": "deviceProfile",
            "type": "ApiDeviceProfile"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateDeviceProfileRequest.attributeTypeMap;
    }
}

export class ApiCreateDeviceProfileResponse {
    /**
    * Device-profile ID (UUID string).
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateDeviceProfileResponse.attributeTypeMap;
    }
}

export class ApiCreateDeviceRequest {
    /**
    * Device object to create.
    */
    'device': ApiDevice;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "device",
            "baseName": "device",
            "type": "ApiDevice"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateDeviceRequest.attributeTypeMap;
    }
}

export class ApiCreateGatewayProfileRequest {
    /**
    * Gateway-profile object to create.
    */
    'gatewayProfile': ApiGatewayProfile;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gatewayProfile",
            "baseName": "gatewayProfile",
            "type": "ApiGatewayProfile"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateGatewayProfileRequest.attributeTypeMap;
    }
}

export class ApiCreateGatewayProfileResponse {
    /**
    * Gateway-profile ID (UUID string).
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateGatewayProfileResponse.attributeTypeMap;
    }
}

export class ApiCreateGatewayRequest {
    /**
    * Gateway object to create.
    */
    'gateway': ApiGateway;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "ApiGateway"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateGatewayRequest.attributeTypeMap;
    }
}

export class ApiCreateHTTPIntegrationRequest {
    /**
    * Integration object to create.
    */
    'integration': ApiHTTPIntegration;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "integration",
            "baseName": "integration",
            "type": "ApiHTTPIntegration"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateHTTPIntegrationRequest.attributeTypeMap;
    }
}

export class ApiCreateInfluxDBIntegrationRequest {
    /**
    * Integration object to create.
    */
    'integration': ApiInfluxDBIntegration;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "integration",
            "baseName": "integration",
            "type": "ApiInfluxDBIntegration"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateInfluxDBIntegrationRequest.attributeTypeMap;
    }
}

export class ApiCreateMulticastGroupRequest {
    /**
    * Multicast-group object to create.
    */
    'multicastGroup': ApiMulticastGroup;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "multicastGroup",
            "baseName": "multicastGroup",
            "type": "ApiMulticastGroup"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateMulticastGroupRequest.attributeTypeMap;
    }
}

export class ApiCreateMulticastGroupResponse {
    /**
    * ID of created group (string formatted UUID).
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateMulticastGroupResponse.attributeTypeMap;
    }
}

export class ApiCreateNetworkServerRequest {
    /**
    * Network-server object to create.
    */
    'networkServer': ApiNetworkServer;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "networkServer",
            "baseName": "networkServer",
            "type": "ApiNetworkServer"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateNetworkServerRequest.attributeTypeMap;
    }
}

export class ApiCreateNetworkServerResponse {
    /**
    * Network-server ID.
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateNetworkServerResponse.attributeTypeMap;
    }
}

export class ApiCreateOrganizationRequest {
    /**
    * Organization object to create.
    */
    'organization': ApiOrganization;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organization",
            "baseName": "organization",
            "type": "ApiOrganization"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateOrganizationRequest.attributeTypeMap;
    }
}

export class ApiCreateOrganizationResponse {
    /**
    * Organization ID.
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateOrganizationResponse.attributeTypeMap;
    }
}

export class ApiCreateServiceProfileRequest {
    /**
    * Service-profile object to create.
    */
    'serviceProfile': ApiServiceProfile;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "serviceProfile",
            "baseName": "serviceProfile",
            "type": "ApiServiceProfile"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateServiceProfileRequest.attributeTypeMap;
    }
}

export class ApiCreateServiceProfileResponse {
    /**
    * Service-profile ID (UUID string).
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateServiceProfileResponse.attributeTypeMap;
    }
}

export class ApiCreateUserRequest {
    /**
    * Add the user to the following organizations.
    */
    'organizations': Array<ApiUserOrganization>;
    /**
    * Password of the user.
    */
    'password': string;
    /**
    * User object to create.
    */
    'user': ApiUser;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizations",
            "baseName": "organizations",
            "type": "Array<ApiUserOrganization>"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ApiUser"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateUserRequest.attributeTypeMap;
    }
}

export class ApiCreateUserResponse {
    /**
    * User ID.
    */
    'id': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiCreateUserResponse.attributeTypeMap;
    }
}

export class ApiDevice {
    /**
    * ID of the application to which the device must be added.
    */
    'applicationID': string;
    /**
    * Description of the device.
    */
    'description': string;
    /**
    * Device EUI (HEX encoded).
    */
    'devEUI': string;
    /**
    * DeviceProfileID attached to the device.
    */
    'deviceProfileID': string;
    /**
    * Name of the device (if left blank, it will be set to the DevEUI).
    */
    'name': string;
    /**
    * Reference altitude. When using geolocation, this altitude will be used as a reference (when supported by the geolocation-server) to increase geolocation accuracy.
    */
    'referenceAltitude': number;
    /**
    * Skip frame-counter checks (this is insecure, but could be helpful for debugging).
    */
    'skipFCntCheck': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationID",
            "baseName": "applicationID",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "devEUI",
            "baseName": "devEUI",
            "type": "string"
        },
        {
            "name": "deviceProfileID",
            "baseName": "deviceProfileID",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "referenceAltitude",
            "baseName": "referenceAltitude",
            "type": "number"
        },
        {
            "name": "skipFCntCheck",
            "baseName": "skipFCntCheck",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ApiDevice.attributeTypeMap;
    }
}

export class ApiDeviceActivation {
    /**
    * Downlink application frame-counter.
    */
    'aFCntDown': number;
    /**
    * Application session key (HEX encoded).
    */
    'appSKey': string;
    /**
    * Device address (HEX encoded).
    */
    'devAddr': string;
    /**
    * Device EUI (HEX encoded).
    */
    'devEUI': string;
    /**
    * Uplink frame-counter.
    */
    'fCntUp': number;
    /**
    * Forwarding network session integrity key (HEX encoded).
    */
    'fNwkSIntKey': string;
    /**
    * Downlink network frame-counter.
    */
    'nFCntDown': number;
    /**
    * Network session encryption key (HEX encoded).
    */
    'nwkSEncKey': string;
    /**
    * Serving network session integrity key (HEX encoded).
    */
    'sNwkSIntKey': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aFCntDown",
            "baseName": "aFCntDown",
            "type": "number"
        },
        {
            "name": "appSKey",
            "baseName": "appSKey",
            "type": "string"
        },
        {
            "name": "devAddr",
            "baseName": "devAddr",
            "type": "string"
        },
        {
            "name": "devEUI",
            "baseName": "devEUI",
            "type": "string"
        },
        {
            "name": "fCntUp",
            "baseName": "fCntUp",
            "type": "number"
        },
        {
            "name": "fNwkSIntKey",
            "baseName": "fNwkSIntKey",
            "type": "string"
        },
        {
            "name": "nFCntDown",
            "baseName": "nFCntDown",
            "type": "number"
        },
        {
            "name": "nwkSEncKey",
            "baseName": "nwkSEncKey",
            "type": "string"
        },
        {
            "name": "sNwkSIntKey",
            "baseName": "sNwkSIntKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiDeviceActivation.attributeTypeMap;
    }
}

export class ApiDeviceKeys {
    /**
    * Application root key (HEX encoded). Note: This field only needs to be set for LoRaWAN 1.1.x devices!
    */
    'appKey': string;
    /**
    * Device EUI (HEX encoded).
    */
    'devEUI': string;
    /**
    * Network root key (HEX encoded). Note: For LoRaWAN 1.0.x, use this field for the LoRaWAN 1.0.x 'AppKey`!
    */
    'nwkKey': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "appKey",
            "baseName": "appKey",
            "type": "string"
        },
        {
            "name": "devEUI",
            "baseName": "devEUI",
            "type": "string"
        },
        {
            "name": "nwkKey",
            "baseName": "nwkKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiDeviceKeys.attributeTypeMap;
    }
}

export class ApiDeviceListItem {
    /**
    * Application ID.
    */
    'applicationID': string;
    /**
    * Description of the device.
    */
    'description': string;
    /**
    * Device EUI (HEX encoded).
    */
    'devEUI': string;
    /**
    * Device-profile ID attached to the device.
    */
    'deviceProfileID': string;
    /**
    * Device-profile name.
    */
    'deviceProfileName': string;
    /**
    * The device battery status 0:      The end-device is connected to an external power source 1..254: The battery level, 1 being at minimum and 254 being at maximum 255:    The end-device was not able to measure the battery level 256:    The device-status is not available.
    */
    'deviceStatusBattery': number;
    /**
    * The device margin status -32..32: The demodulation SNR ration in dB 256:     The device-status is not available.
    */
    'deviceStatusMargin': number;
    /**
    * The last time the application-server received any data from the device, or an empty string when the device never sent any data.
    */
    'lastSeenAt': Date;
    /**
    * Name of the device.
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationID",
            "baseName": "applicationID",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "devEUI",
            "baseName": "devEUI",
            "type": "string"
        },
        {
            "name": "deviceProfileID",
            "baseName": "deviceProfileID",
            "type": "string"
        },
        {
            "name": "deviceProfileName",
            "baseName": "deviceProfileName",
            "type": "string"
        },
        {
            "name": "deviceStatusBattery",
            "baseName": "deviceStatusBattery",
            "type": "number"
        },
        {
            "name": "deviceStatusMargin",
            "baseName": "deviceStatusMargin",
            "type": "number"
        },
        {
            "name": "lastSeenAt",
            "baseName": "lastSeenAt",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiDeviceListItem.attributeTypeMap;
    }
}

export class ApiDeviceProfile {
    /**
    * Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class B mode supported).
    */
    'classBTimeout': number;
    /**
    * Maximum delay for the End-Device to answer a MAC request or a confirmed DL frame (mandatory if class C mode supported).
    */
    'classCTimeout': number;
    /**
    * List of factory-preset frequencies (mandatory for ABP).
    */
    'factoryPresetFreqs': Array<number>;
    /**
    * Device-profile ID (UUID string).
    */
    'id': string;
    /**
    * Version of the LoRaWAN supported by the End-Device.
    */
    'macVersion': string;
    /**
    * Maximum duty cycle supported by the End-Device.
    */
    'maxDutyCycle': number;
    /**
    * Maximum EIRP supported by the End-Device.
    */
    'maxEIRP': number;
    /**
    * Device-profile name.
    */
    'name': string;
    /**
    * Network-server ID on which the service-profile is provisioned.
    */
    'networkServerID': string;
    /**
    * Organization ID to which the service-profile is assigned.
    */
    'organizationID': string;
    /**
    * Mandatory if class B mode supported.
    */
    'pingSlotDR': number;
    /**
    * Mandatory if class B mode supported.
    */
    'pingSlotFreq': number;
    /**
    * Mandatory if class B mode supported.
    */
    'pingSlotPeriod': number;
    /**
    * Revision of the Regional Parameters document supported by the End-Device.
    */
    'regParamsRevision': string;
    /**
    * RF region name.
    */
    'rfRegion': string;
    /**
    * RX1 data rate offset (mandatory for ABP).
    */
    'rxDROffset1': number;
    /**
    * RX2 data rate (mandatory for ABP).
    */
    'rxDataRate2': number;
    /**
    * Class A RX1 delay (mandatory for ABP).
    */
    'rxDelay1': number;
    /**
    * RX2 channel frequency (mandatory for ABP).
    */
    'rxFreq2': number;
    /**
    * End-Device uses 32bit FCnt (mandatory for LoRaWAN 1.0 End-Device).
    */
    'supports32BitFCnt': boolean;
    /**
    * End-Device supports Class B.
    */
    'supportsClassB': boolean;
    /**
    * End-Device supports Class C.
    */
    'supportsClassC': boolean;
    /**
    * End-Device supports Join (OTAA) or not (ABP).
    */
    'supportsJoin': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "classBTimeout",
            "baseName": "classBTimeout",
            "type": "number"
        },
        {
            "name": "classCTimeout",
            "baseName": "classCTimeout",
            "type": "number"
        },
        {
            "name": "factoryPresetFreqs",
            "baseName": "factoryPresetFreqs",
            "type": "Array<number>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "macVersion",
            "baseName": "macVersion",
            "type": "string"
        },
        {
            "name": "maxDutyCycle",
            "baseName": "maxDutyCycle",
            "type": "number"
        },
        {
            "name": "maxEIRP",
            "baseName": "maxEIRP",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "networkServerID",
            "baseName": "networkServerID",
            "type": "string"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "pingSlotDR",
            "baseName": "pingSlotDR",
            "type": "number"
        },
        {
            "name": "pingSlotFreq",
            "baseName": "pingSlotFreq",
            "type": "number"
        },
        {
            "name": "pingSlotPeriod",
            "baseName": "pingSlotPeriod",
            "type": "number"
        },
        {
            "name": "regParamsRevision",
            "baseName": "regParamsRevision",
            "type": "string"
        },
        {
            "name": "rfRegion",
            "baseName": "rfRegion",
            "type": "string"
        },
        {
            "name": "rxDROffset1",
            "baseName": "rxDROffset1",
            "type": "number"
        },
        {
            "name": "rxDataRate2",
            "baseName": "rxDataRate2",
            "type": "number"
        },
        {
            "name": "rxDelay1",
            "baseName": "rxDelay1",
            "type": "number"
        },
        {
            "name": "rxFreq2",
            "baseName": "rxFreq2",
            "type": "number"
        },
        {
            "name": "supports32BitFCnt",
            "baseName": "supports32BitFCnt",
            "type": "boolean"
        },
        {
            "name": "supportsClassB",
            "baseName": "supportsClassB",
            "type": "boolean"
        },
        {
            "name": "supportsClassC",
            "baseName": "supportsClassC",
            "type": "boolean"
        },
        {
            "name": "supportsJoin",
            "baseName": "supportsJoin",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ApiDeviceProfile.attributeTypeMap;
    }
}

export class ApiDeviceProfileListItem {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Device-profile ID (UUID string).
    */
    'id': string;
    /**
    * Device-profile name.
    */
    'name': string;
    /**
    * Network-server ID.
    */
    'networkServerID': string;
    /**
    * Organization ID.
    */
    'organizationID': string;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "networkServerID",
            "baseName": "networkServerID",
            "type": "string"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiDeviceProfileListItem.attributeTypeMap;
    }
}

export class ApiDeviceQueueItem {
    /**
    * Set this to true when an acknowledgement from the device is required. Please note that this must not be used to guarantee a delivery.
    */
    'confirmed': boolean;
    /**
    * Base64 encoded data. Or use the json_object field when an application codec has been configured.
    */
    'data': string;
    /**
    * Device EUI (HEX encoded).
    */
    'devEUI': string;
    /**
    * Downlink frame-counter. This will be automatically set on enquue.
    */
    'fCnt': number;
    /**
    * FPort used (must be > 0)
    */
    'fPort': number;
    /**
    * JSON object (string). Only use this when an application codec has been configured that can convert this object into binary form.
    */
    'jsonObject': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "confirmed",
            "baseName": "confirmed",
            "type": "boolean"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        },
        {
            "name": "devEUI",
            "baseName": "devEUI",
            "type": "string"
        },
        {
            "name": "fCnt",
            "baseName": "fCnt",
            "type": "number"
        },
        {
            "name": "fPort",
            "baseName": "fPort",
            "type": "number"
        },
        {
            "name": "jsonObject",
            "baseName": "jsonObject",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiDeviceQueueItem.attributeTypeMap;
    }
}

export class ApiDownlinkFrameLog {
    /**
    * LoRaWAN PHYPayload.
    */
    'phyPayloadJSON': string;
    /**
    * TX information of the downlink.
    */
    'txInfo': ApiDownlinkTXInfo;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phyPayloadJSON",
            "baseName": "phyPayloadJSON",
            "type": "string"
        },
        {
            "name": "txInfo",
            "baseName": "txInfo",
            "type": "ApiDownlinkTXInfo"
        }    ];

    static getAttributeTypeMap() {
        return ApiDownlinkFrameLog.attributeTypeMap;
    }
}

/**
* Same comment as above applies to this message.
*/
export class ApiDownlinkTXInfo {
    /**
    * The antenna identifier for emitting the frame.
    */
    'antenna': number;
    /**
    * The board identifier for emitting the frame.
    */
    'board': number;
    /**
    * TX frequency (in Hz).
    */
    'frequency': number;
    /**
    * FSK modulation information.
    */
    'fskModulationInfo': GwFSKModulationInfo;
    /**
    * Gateway ID.
    */
    'gatewayId': string;
    /**
    * Frame must be sent immediately.
    */
    'immediately': boolean;
    /**
    * LoRa modulation information.
    */
    'loraModulationInfo': GwLoRaModulationInfo;
    /**
    * Modulation.
    */
    'modulation': CommonModulation;
    /**
    * TX power (in dBm).
    */
    'power': number;
    /**
    * Emit frame at the given time since GPS epoch.
    */
    'timeSinceGpsEpoch': string;
    /**
    * Emit the frame at the given gateway internal timestamp.
    */
    'timestamp': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "antenna",
            "baseName": "antenna",
            "type": "number"
        },
        {
            "name": "board",
            "baseName": "board",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "fskModulationInfo",
            "baseName": "fskModulationInfo",
            "type": "GwFSKModulationInfo"
        },
        {
            "name": "gatewayId",
            "baseName": "gatewayId",
            "type": "string"
        },
        {
            "name": "immediately",
            "baseName": "immediately",
            "type": "boolean"
        },
        {
            "name": "loraModulationInfo",
            "baseName": "loraModulationInfo",
            "type": "GwLoRaModulationInfo"
        },
        {
            "name": "modulation",
            "baseName": "modulation",
            "type": "CommonModulation"
        },
        {
            "name": "power",
            "baseName": "power",
            "type": "number"
        },
        {
            "name": "timeSinceGpsEpoch",
            "baseName": "timeSinceGpsEpoch",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiDownlinkTXInfo.attributeTypeMap;
    }
}

/**
* this s a copy of gw.EncryptedFineTimestamp which the only change that the fpga_id is of type string so that it can be returned in HEX format instead of base64.
*/
export class ApiEncryptedFineTimestamp {
    /**
    * AES key index used for encrypting the fine timestamp.
    */
    'aesKeyIndex': number;
    /**
    * Encrypted 'main' fine-timestamp (ns precision part of the timestamp).
    */
    'encryptedNS': string;
    /**
    * FPGA ID.
    */
    'fpgaID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aesKeyIndex",
            "baseName": "aesKeyIndex",
            "type": "number"
        },
        {
            "name": "encryptedNS",
            "baseName": "encryptedNS",
            "type": "string"
        },
        {
            "name": "fpgaID",
            "baseName": "fpgaID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiEncryptedFineTimestamp.attributeTypeMap;
    }
}

export class ApiEnqueueDeviceQueueItemRequest {
    /**
    * Queue-item object to enqueue.
    */
    'deviceQueueItem': ApiDeviceQueueItem;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceQueueItem",
            "baseName": "deviceQueueItem",
            "type": "ApiDeviceQueueItem"
        }    ];

    static getAttributeTypeMap() {
        return ApiEnqueueDeviceQueueItemRequest.attributeTypeMap;
    }
}

export class ApiEnqueueDeviceQueueItemResponse {
    /**
    * Frame-counter for the enqueued payload.
    */
    'fCnt': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fCnt",
            "baseName": "fCnt",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiEnqueueDeviceQueueItemResponse.attributeTypeMap;
    }
}

export class ApiEnqueueMulticastQueueItemRequest {
    /**
    * Multicast queue-item object to enqueue.
    */
    'multicastQueueItem': ApiMulticastQueueItem;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "multicastQueueItem",
            "baseName": "multicastQueueItem",
            "type": "ApiMulticastQueueItem"
        }    ];

    static getAttributeTypeMap() {
        return ApiEnqueueMulticastQueueItemRequest.attributeTypeMap;
    }
}

export class ApiEnqueueMulticastQueueItemResponse {
    /**
    * Frame-counter for the enqueued payload.
    */
    'fCnt': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fCnt",
            "baseName": "fCnt",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiEnqueueMulticastQueueItemResponse.attributeTypeMap;
    }
}

export class ApiGateway {
    /**
    * Gateway boards configuration (optional). This is (currently) only needed when the gateway supports the fine-timestamp and you you would like to add the FPGA ID to the gateway meta-data or would like LoRa Server to decrypt the fine-timestamp.
    */
    'boards': Array<ApiGatewayBoard>;
    /**
    * Gateway description.
    */
    'description': string;
    /**
    * Set to true to enable gateway discovery.
    */
    'discoveryEnabled': boolean;
    /**
    * Gateway-profile ID (UUID string, optional).
    */
    'gatewayProfileID': string;
    /**
    * Gateway ID (HEX encoded).
    */
    'id': string;
    /**
    * Gateway location.
    */
    'location': CommonLocation;
    /**
    * Gateway name.
    */
    'name': string;
    /**
    * Network-server ID on which the gateway is provisioned.
    */
    'networkServerID': string;
    /**
    * Organization ID to which the gateway belongs. This can't be changed after creating the gateway.
    */
    'organizationID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "boards",
            "baseName": "boards",
            "type": "Array<ApiGatewayBoard>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "discoveryEnabled",
            "baseName": "discoveryEnabled",
            "type": "boolean"
        },
        {
            "name": "gatewayProfileID",
            "baseName": "gatewayProfileID",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "CommonLocation"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "networkServerID",
            "baseName": "networkServerID",
            "type": "string"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiGateway.attributeTypeMap;
    }
}

export class ApiGatewayBoard {
    /**
    * Fine-timestamp AES decryption key (HEX encoded) (optional).
    */
    'fineTimestampKey': string;
    /**
    * FPGA ID of the gateway (HEX encoded) (optional).
    */
    'fpgaID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fineTimestampKey",
            "baseName": "fineTimestampKey",
            "type": "string"
        },
        {
            "name": "fpgaID",
            "baseName": "fpgaID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiGatewayBoard.attributeTypeMap;
    }
}

export class ApiGatewayListItem {
    /**
    * Create timestamp.
    */
    'createdAt': Date;
    /**
    * A description for the gateway
    */
    'description': string;
    /**
    * Gateway ID (HEX encoded).
    */
    'id': string;
    /**
    * A name for the gateway
    */
    'name': string;
    /**
    * Network-server ID.
    */
    'networkServerID': string;
    /**
    * Organization ID.
    */
    'organizationID': string;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "networkServerID",
            "baseName": "networkServerID",
            "type": "string"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGatewayListItem.attributeTypeMap;
    }
}

export class ApiGatewayProfile {
    /**
    * Default channels (channels specified by the LoRaWAN Regional Parameters specification) enabled for this configuration.
    */
    'channels': Array<number>;
    /**
    * Extra channels added to the channel-configuration (in case the LoRaWAN region supports adding custom channels).
    */
    'extraChannels': Array<ApiGatewayProfileExtraChannel>;
    /**
    * Gateway-profile ID (UUID string).
    */
    'id': string;
    /**
    * Name of the gateway-profile.
    */
    'name': string;
    /**
    * Network-server ID of the gateway-profile.
    */
    'networkServerID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "channels",
            "baseName": "channels",
            "type": "Array<number>"
        },
        {
            "name": "extraChannels",
            "baseName": "extraChannels",
            "type": "Array<ApiGatewayProfileExtraChannel>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "networkServerID",
            "baseName": "networkServerID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiGatewayProfile.attributeTypeMap;
    }
}

export class ApiGatewayProfileExtraChannel {
    /**
    * Bandwidth.
    */
    'bandwidth': number;
    /**
    * Bitrate (in case of FSK modulation).
    */
    'bitrate': number;
    /**
    * Frequency.
    */
    'frequency': number;
    /**
    * Modulation.
    */
    'modulation': CommonModulation;
    /**
    * Spreading factors (in case of LoRa modulation).
    */
    'spreadingFactors': Array<number>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bandwidth",
            "baseName": "bandwidth",
            "type": "number"
        },
        {
            "name": "bitrate",
            "baseName": "bitrate",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "modulation",
            "baseName": "modulation",
            "type": "CommonModulation"
        },
        {
            "name": "spreadingFactors",
            "baseName": "spreadingFactors",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return ApiGatewayProfileExtraChannel.attributeTypeMap;
    }
}

export class ApiGatewayProfileListItem {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Gateway-profile ID (UUID string).
    */
    'id': string;
    /**
    * Gateway-profile name,
    */
    'name': string;
    /**
    * Network-server ID on which the gateway-profile is provisioned.
    */
    'networkServerID': string;
    /**
    * Network-server name.
    */
    'networkServerName': string;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "networkServerID",
            "baseName": "networkServerID",
            "type": "string"
        },
        {
            "name": "networkServerName",
            "baseName": "networkServerName",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGatewayProfileListItem.attributeTypeMap;
    }
}

export class ApiGatewayStats {
    /**
    * Packets received by the gateway.
    */
    'rxPacketsReceived': number;
    /**
    * Packets received by the gateway that passed the CRC check.
    */
    'rxPacketsReceivedOK': number;
    /**
    * Timestamp of the (aggregated) measurement.
    */
    'timestamp': Date;
    /**
    * Packets transmitted by the gateway.
    */
    'txPacketsEmitted': number;
    /**
    * Packets received by the gateway for transmission.
    */
    'txPacketsReceived': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rxPacketsReceived",
            "baseName": "rxPacketsReceived",
            "type": "number"
        },
        {
            "name": "rxPacketsReceivedOK",
            "baseName": "rxPacketsReceivedOK",
            "type": "number"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        },
        {
            "name": "txPacketsEmitted",
            "baseName": "txPacketsEmitted",
            "type": "number"
        },
        {
            "name": "txPacketsReceived",
            "baseName": "txPacketsReceived",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiGatewayStats.attributeTypeMap;
    }
}

export class ApiGetApplicationResponse {
    /**
    * Application object.
    */
    'application': ApiApplication;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "application",
            "baseName": "application",
            "type": "ApiApplication"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetApplicationResponse.attributeTypeMap;
    }
}

export class ApiGetDeviceActivationResponse {
    /**
    * Device-activation object.
    */
    'deviceActivation': ApiDeviceActivation;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceActivation",
            "baseName": "deviceActivation",
            "type": "ApiDeviceActivation"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetDeviceActivationResponse.attributeTypeMap;
    }
}

export class ApiGetDeviceKeysResponse {
    /**
    * Device-key object.
    */
    'deviceKeys': ApiDeviceKeys;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceKeys",
            "baseName": "deviceKeys",
            "type": "ApiDeviceKeys"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetDeviceKeysResponse.attributeTypeMap;
    }
}

export class ApiGetDeviceProfileResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Device-profile object.
    */
    'deviceProfile': ApiDeviceProfile;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "deviceProfile",
            "baseName": "deviceProfile",
            "type": "ApiDeviceProfile"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetDeviceProfileResponse.attributeTypeMap;
    }
}

export class ApiGetDeviceResponse {
    /**
    * Device object.
    */
    'device': ApiDevice;
    /**
    * The device battery status 0:      The end-device is connected to an external power source 1..254: The battery level, 1 being at minimum and 254 being at maximum 255:    The end-device was not able to measure the battery level 256:    The device-status is not available.
    */
    'deviceStatusBattery': number;
    /**
    * The device margin status -32..32: The demodulation SNR ration in dB 256:     The device-status is not available.
    */
    'deviceStatusMargin': number;
    /**
    * Last seen timestamp.
    */
    'lastSeenAt': Date;
    /**
    * Device location. This will set when the network-server was able to resolve the location using the geolocation-server.
    */
    'location': CommonLocation;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "device",
            "baseName": "device",
            "type": "ApiDevice"
        },
        {
            "name": "deviceStatusBattery",
            "baseName": "deviceStatusBattery",
            "type": "number"
        },
        {
            "name": "deviceStatusMargin",
            "baseName": "deviceStatusMargin",
            "type": "number"
        },
        {
            "name": "lastSeenAt",
            "baseName": "lastSeenAt",
            "type": "Date"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "CommonLocation"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetDeviceResponse.attributeTypeMap;
    }
}

export class ApiGetGatewayProfileResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Gateway-profile object.
    */
    'gatewayProfile': ApiGatewayProfile;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "gatewayProfile",
            "baseName": "gatewayProfile",
            "type": "ApiGatewayProfile"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetGatewayProfileResponse.attributeTypeMap;
    }
}

export class ApiGetGatewayResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * First seen at timestamp.
    */
    'firstSeenAt': Date;
    /**
    * Gateway object.
    */
    'gateway': ApiGateway;
    /**
    * Last seen at timestamp.
    */
    'lastSeenAt': Date;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "firstSeenAt",
            "baseName": "firstSeenAt",
            "type": "Date"
        },
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "ApiGateway"
        },
        {
            "name": "lastSeenAt",
            "baseName": "lastSeenAt",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetGatewayResponse.attributeTypeMap;
    }
}

export class ApiGetGatewayStatsResponse {
    'result': Array<ApiGatewayStats>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiGatewayStats>"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetGatewayStatsResponse.attributeTypeMap;
    }
}

export class ApiGetHTTPIntegrationResponse {
    /**
    * Integration object.
    */
    'integration': ApiHTTPIntegration;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "integration",
            "baseName": "integration",
            "type": "ApiHTTPIntegration"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetHTTPIntegrationResponse.attributeTypeMap;
    }
}

export class ApiGetInfluxDBIntegrationResponse {
    /**
    * Integration object.
    */
    'integration': ApiInfluxDBIntegration;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "integration",
            "baseName": "integration",
            "type": "ApiInfluxDBIntegration"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetInfluxDBIntegrationResponse.attributeTypeMap;
    }
}

export class ApiGetLastPingResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Data-rate.
    */
    'dr': number;
    /**
    * Frequency (Hz).
    */
    'frequency': number;
    /**
    * Gateways and meta-data of reception.
    */
    'pingRX': Array<ApiPingRX>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "dr",
            "baseName": "dr",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "pingRX",
            "baseName": "pingRX",
            "type": "Array<ApiPingRX>"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetLastPingResponse.attributeTypeMap;
    }
}

export class ApiGetMulticastGroupResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Multicast-group object.
    */
    'multicastGroup': ApiMulticastGroup;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "multicastGroup",
            "baseName": "multicastGroup",
            "type": "ApiMulticastGroup"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetMulticastGroupResponse.attributeTypeMap;
    }
}

export class ApiGetNetworkServerResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Network-server object.
    */
    'networkServer': ApiNetworkServer;
    /**
    * The LoRa Server region configured.
    */
    'region': string;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;
    /**
    * The LoRa Server version.
    */
    'version': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "networkServer",
            "baseName": "networkServer",
            "type": "ApiNetworkServer"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetNetworkServerResponse.attributeTypeMap;
    }
}

export class ApiGetOrganizationResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Organization object.
    */
    'organization': ApiOrganization;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "ApiOrganization"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetOrganizationResponse.attributeTypeMap;
    }
}

/**
* Response for a user in the organization
*/
export class ApiGetOrganizationUserResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Organization-user object.
    */
    'organizationUser': ApiOrganizationUser;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "organizationUser",
            "baseName": "organizationUser",
            "type": "ApiOrganizationUser"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetOrganizationUserResponse.attributeTypeMap;
    }
}

export class ApiGetRandomDevAddrResponse {
    /**
    * Device address (HEX encoded).
    */
    'devAddr': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "devAddr",
            "baseName": "devAddr",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetRandomDevAddrResponse.attributeTypeMap;
    }
}

export class ApiGetServiceProfileResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Service-profile object.
    */
    'serviceProfile': ApiServiceProfile;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "serviceProfile",
            "baseName": "serviceProfile",
            "type": "ApiServiceProfile"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetServiceProfileResponse.attributeTypeMap;
    }
}

export class ApiGetUserResponse {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;
    /**
    * User object.
    */
    'user': ApiUser;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ApiUser"
        }    ];

    static getAttributeTypeMap() {
        return ApiGetUserResponse.attributeTypeMap;
    }
}

export class ApiGlobalSearchResponse {
    'result': Array<ApiGlobalSearchResult>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiGlobalSearchResult>"
        }    ];

    static getAttributeTypeMap() {
        return ApiGlobalSearchResponse.attributeTypeMap;
    }
}

export class ApiGlobalSearchResult {
    /**
    * Application id.
    */
    'applicationID': string;
    /**
    * Application name.
    */
    'applicationName': string;
    /**
    * Device DevEUI (hex encoded).
    */
    'deviceDevEUI': string;
    /**
    * Device name.
    */
    'deviceName': string;
    /**
    * Gateway MAC (hex encoded).
    */
    'gatewayMAC': string;
    /**
    * Gateway name.
    */
    'gatewayName': string;
    /**
    * Record kind.
    */
    'kind': string;
    /**
    * Organization id.
    */
    'organizationID': string;
    /**
    * Organization name.
    */
    'organizationName': string;
    /**
    * Search score.
    */
    'score': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationID",
            "baseName": "applicationID",
            "type": "string"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "deviceDevEUI",
            "baseName": "deviceDevEUI",
            "type": "string"
        },
        {
            "name": "deviceName",
            "baseName": "deviceName",
            "type": "string"
        },
        {
            "name": "gatewayMAC",
            "baseName": "gatewayMAC",
            "type": "string"
        },
        {
            "name": "gatewayName",
            "baseName": "gatewayName",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "organizationName",
            "baseName": "organizationName",
            "type": "string"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiGlobalSearchResult.attributeTypeMap;
    }
}

export class ApiHTTPIntegration {
    /**
    * The URL to call for ACK notifications (for confirmed downlink data).
    */
    'ackNotificationURL': string;
    /**
    * The id of the application.
    */
    'applicationID': string;
    /**
    * The URL to call for error notifications.
    */
    'errorNotificationURL': string;
    /**
    * The headers to use when making HTTP callbacks.
    */
    'headers': Array<ApiHTTPIntegrationHeader>;
    /**
    * The URL to call for join notifications.
    */
    'joinNotificationURL': string;
    /**
    * The URL to call for location notifications.
    */
    'locationNotificationURL': string;
    /**
    * The URL to call for device-status notifications.
    */
    'statusNotificationURL': string;
    /**
    * The URL to call for uplink data.
    */
    'uplinkDataURL': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ackNotificationURL",
            "baseName": "ackNotificationURL",
            "type": "string"
        },
        {
            "name": "applicationID",
            "baseName": "applicationID",
            "type": "string"
        },
        {
            "name": "errorNotificationURL",
            "baseName": "errorNotificationURL",
            "type": "string"
        },
        {
            "name": "headers",
            "baseName": "headers",
            "type": "Array<ApiHTTPIntegrationHeader>"
        },
        {
            "name": "joinNotificationURL",
            "baseName": "joinNotificationURL",
            "type": "string"
        },
        {
            "name": "locationNotificationURL",
            "baseName": "locationNotificationURL",
            "type": "string"
        },
        {
            "name": "statusNotificationURL",
            "baseName": "statusNotificationURL",
            "type": "string"
        },
        {
            "name": "uplinkDataURL",
            "baseName": "uplinkDataURL",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiHTTPIntegration.attributeTypeMap;
    }
}

export class ApiHTTPIntegrationHeader {
    /**
    * Key
    */
    'key': string;
    /**
    * Value
    */
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiHTTPIntegrationHeader.attributeTypeMap;
    }
}

export class ApiInfluxDBIntegration {
    /**
    * Application ID.
    */
    'applicationID': string;
    /**
    * InfluxDB database name.
    */
    'db': string;
    /**
    * InfluxDB API write endpoint (e.g. http://localhost:8086/write).
    */
    'endpoint': string;
    /**
    * InfluxDB password.
    */
    'password': string;
    /**
    * InfluxDB timestamp precision.
    */
    'precision': ApiInfluxDBPrecision;
    /**
    * InfluxDB retention policy name.
    */
    'retentionPolicyName': string;
    /**
    * InfluxDB username.
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationID",
            "baseName": "applicationID",
            "type": "string"
        },
        {
            "name": "db",
            "baseName": "db",
            "type": "string"
        },
        {
            "name": "endpoint",
            "baseName": "endpoint",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "precision",
            "baseName": "precision",
            "type": "ApiInfluxDBPrecision"
        },
        {
            "name": "retentionPolicyName",
            "baseName": "retentionPolicyName",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiInfluxDBIntegration.attributeTypeMap;
    }
}

export class ApiInfluxDBPrecision {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ApiInfluxDBPrecision.attributeTypeMap;
    }
}

export class ApiIntegrationKind {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ApiIntegrationKind.attributeTypeMap;
    }
}

export class ApiIntegrationListItem {
    /**
    * Integration kind.
    */
    'kind': ApiIntegrationKind;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "kind",
            "baseName": "kind",
            "type": "ApiIntegrationKind"
        }    ];

    static getAttributeTypeMap() {
        return ApiIntegrationListItem.attributeTypeMap;
    }
}

export class ApiListApplicationResponse {
    /**
    * Applications within this result-set.
    */
    'result': Array<ApiApplicationListItem>;
    /**
    * Total number of applications available within the result-set.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiApplicationListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListApplicationResponse.attributeTypeMap;
    }
}

export class ApiListDeviceProfileResponse {
    'result': Array<ApiDeviceProfileListItem>;
    /**
    * Total number of device-profiles.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiDeviceProfileListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListDeviceProfileResponse.attributeTypeMap;
    }
}

export class ApiListDeviceQueueItemsResponse {
    'deviceQueueItems': Array<ApiDeviceQueueItem>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceQueueItems",
            "baseName": "deviceQueueItems",
            "type": "Array<ApiDeviceQueueItem>"
        }    ];

    static getAttributeTypeMap() {
        return ApiListDeviceQueueItemsResponse.attributeTypeMap;
    }
}

export class ApiListDeviceResponse {
    /**
    * Devices within this result-set.
    */
    'result': Array<ApiDeviceListItem>;
    /**
    * Total number of devices available within the result-set.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiDeviceListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListDeviceResponse.attributeTypeMap;
    }
}

export class ApiListGatewayProfilesResponse {
    'result': Array<ApiGatewayProfileListItem>;
    /**
    * Total number of gateway-profiles.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiGatewayProfileListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListGatewayProfilesResponse.attributeTypeMap;
    }
}

export class ApiListGatewayResponse {
    /**
    * Nodes within this result-set.
    */
    'result': Array<ApiGatewayListItem>;
    /**
    * Total number of nodes available within the result-set.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiGatewayListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListGatewayResponse.attributeTypeMap;
    }
}

export class ApiListIntegrationResponse {
    /**
    * Integrations within result-set.
    */
    'result': Array<ApiIntegrationListItem>;
    /**
    * Total number of integrations available within the result-set.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiIntegrationListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListIntegrationResponse.attributeTypeMap;
    }
}

export class ApiListMulticastGroupQueueItemsResponse {
    'multicastQueueItems': Array<ApiMulticastQueueItem>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "multicastQueueItems",
            "baseName": "multicastQueueItems",
            "type": "Array<ApiMulticastQueueItem>"
        }    ];

    static getAttributeTypeMap() {
        return ApiListMulticastGroupQueueItemsResponse.attributeTypeMap;
    }
}

export class ApiListMulticastGroupResponse {
    'result': Array<ApiMulticastGroupListItem>;
    /**
    * Total number of multicast-groups.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiMulticastGroupListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListMulticastGroupResponse.attributeTypeMap;
    }
}

export class ApiListNetworkServerResponse {
    /**
    * Network-servers within the result-set.
    */
    'result': Array<ApiNetworkServerListItem>;
    /**
    * Total number of network-servers.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiNetworkServerListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListNetworkServerResponse.attributeTypeMap;
    }
}

export class ApiListOrganizationResponse {
    'result': Array<ApiOrganizationListItem>;
    /**
    * Total number of organizations.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiOrganizationListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListOrganizationResponse.attributeTypeMap;
    }
}

export class ApiListOrganizationUsersResponse {
    'result': Array<ApiOrganizationUserListItem>;
    /**
    * The total number of users in the organization.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiOrganizationUserListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListOrganizationUsersResponse.attributeTypeMap;
    }
}

export class ApiListServiceProfileResponse {
    'result': Array<ApiServiceProfileListItem>;
    /**
    * Total number of service-profiles.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiServiceProfileListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListServiceProfileResponse.attributeTypeMap;
    }
}

export class ApiListUserResponse {
    /**
    * Result-set.
    */
    'result': Array<ApiUserListItem>;
    /**
    * Total number of users.
    */
    'totalCount': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "Array<ApiUserListItem>"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiListUserResponse.attributeTypeMap;
    }
}

export class ApiLoginRequest {
    /**
    * Password of the user.
    */
    'password': string;
    /**
    * Username of the user.
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiLoginRequest.attributeTypeMap;
    }
}

export class ApiLoginResponse {
    /**
    * The JWT tag to be used to access lora-app-server interfaces.
    */
    'jwt': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jwt",
            "baseName": "jwt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiLoginResponse.attributeTypeMap;
    }
}

export class ApiMulticastGroup {
    /**
    * Data-rate.
    */
    'dr': number;
    /**
    * Frame-counter.
    */
    'fCnt': number;
    /**
    * Frequency (Hz).
    */
    'frequency': number;
    /**
    * Multicast type.
    */
    'groupType': ApiMulticastGroupType;
    /**
    * ID (string formatted UUID). This will be generated automatically on create.
    */
    'id': string;
    /**
    * Multicast address (HEX encoded DevAddr).
    */
    'mcAddr': string;
    /**
    * Multicast application session key (HEX encoded AES128 key).
    */
    'mcAppSKey': string;
    /**
    * Multicast network session key (HEX encoded AES128 key).
    */
    'mcNwkSKey': string;
    /**
    * Multicast-group name.
    */
    'name': string;
    /**
    * Ping-slot period. Mandatory for Class-B multicast groups.
    */
    'pingSlotPeriod': number;
    /**
    * Service-profile ID. After creation, this can not be updated.
    */
    'serviceProfileID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dr",
            "baseName": "dr",
            "type": "number"
        },
        {
            "name": "fCnt",
            "baseName": "fCnt",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "groupType",
            "baseName": "groupType",
            "type": "ApiMulticastGroupType"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "mcAddr",
            "baseName": "mcAddr",
            "type": "string"
        },
        {
            "name": "mcAppSKey",
            "baseName": "mcAppSKey",
            "type": "string"
        },
        {
            "name": "mcNwkSKey",
            "baseName": "mcNwkSKey",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "pingSlotPeriod",
            "baseName": "pingSlotPeriod",
            "type": "number"
        },
        {
            "name": "serviceProfileID",
            "baseName": "serviceProfileID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiMulticastGroup.attributeTypeMap;
    }
}

export class ApiMulticastGroupListItem {
    /**
    * ID (string formatted UUID).
    */
    'id': string;
    /**
    * Multicast-group name.
    */
    'name': string;
    /**
    * Service-profile ID (string formatted UUID).
    */
    'serviceProfileID': string;
    /**
    * Service-profile name.
    */
    'serviceProfileName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "serviceProfileID",
            "baseName": "serviceProfileID",
            "type": "string"
        },
        {
            "name": "serviceProfileName",
            "baseName": "serviceProfileName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiMulticastGroupListItem.attributeTypeMap;
    }
}

/**
*  - CLASS_C: Class-C.  - CLASS_B: Class-B.
*/
export class ApiMulticastGroupType {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ApiMulticastGroupType.attributeTypeMap;
    }
}

export class ApiMulticastQueueItem {
    /**
    * Base64 encoded data.
    */
    'data': string;
    /**
    * Downlink frame-counter. This will be automatically set on enqueue.
    */
    'fCnt': number;
    /**
    * FPort used (must be > 0).
    */
    'fPort': number;
    /**
    * Multicast-group ID (string formatted UUID).
    */
    'multicastGroupID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        },
        {
            "name": "fCnt",
            "baseName": "fCnt",
            "type": "number"
        },
        {
            "name": "fPort",
            "baseName": "fPort",
            "type": "number"
        },
        {
            "name": "multicastGroupID",
            "baseName": "multicastGroupID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiMulticastQueueItem.attributeTypeMap;
    }
}

export class ApiNetworkServer {
    /**
    * CA certificate (optional).
    */
    'caCert': string;
    /**
    * The data-rate of the gateway discovery 'ping'.
    */
    'gatewayDiscoveryDR': number;
    /**
    * Enable gateway discovery for this network-server.
    */
    'gatewayDiscoveryEnabled': boolean;
    /**
    * The number of times per day the gateway discovery 'ping' must be broadcasted per gateway.
    */
    'gatewayDiscoveryInterval': number;
    /**
    * The frequency (Hz) of the gateway discovery 'ping'.
    */
    'gatewayDiscoveryTXFrequency': number;
    /**
    * Network-server ID.
    */
    'id': string;
    /**
    * Network-server name.
    */
    'name': string;
    /**
    * Routing-profile ca certificate (used by the network-server to connect back to the application-server) (optional).
    */
    'routingProfileCACert': string;
    /**
    * Routing-profile TLS certificate (used by the network-server to connect back to the application-server) (optional).
    */
    'routingProfileTLSCert': string;
    /**
    * Routing-profile TLS key (used by the network-server to connect back to the application-server) (optional).
    */
    'routingProfileTLSKey': string;
    /**
    * Network-server server. Format: hostname:ip (e.g. localhost:8000).
    */
    'server': string;
    /**
    * TLS (client) certificate for connecting to the network-server (optional).
    */
    'tlsCert': string;
    /**
    * TLS (client) key for connecting to the network-server (optional).
    */
    'tlsKey': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "caCert",
            "baseName": "caCert",
            "type": "string"
        },
        {
            "name": "gatewayDiscoveryDR",
            "baseName": "gatewayDiscoveryDR",
            "type": "number"
        },
        {
            "name": "gatewayDiscoveryEnabled",
            "baseName": "gatewayDiscoveryEnabled",
            "type": "boolean"
        },
        {
            "name": "gatewayDiscoveryInterval",
            "baseName": "gatewayDiscoveryInterval",
            "type": "number"
        },
        {
            "name": "gatewayDiscoveryTXFrequency",
            "baseName": "gatewayDiscoveryTXFrequency",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "routingProfileCACert",
            "baseName": "routingProfileCACert",
            "type": "string"
        },
        {
            "name": "routingProfileTLSCert",
            "baseName": "routingProfileTLSCert",
            "type": "string"
        },
        {
            "name": "routingProfileTLSKey",
            "baseName": "routingProfileTLSKey",
            "type": "string"
        },
        {
            "name": "server",
            "baseName": "server",
            "type": "string"
        },
        {
            "name": "tlsCert",
            "baseName": "tlsCert",
            "type": "string"
        },
        {
            "name": "tlsKey",
            "baseName": "tlsKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiNetworkServer.attributeTypeMap;
    }
}

export class ApiNetworkServerListItem {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Network-server ID.
    */
    'id': string;
    /**
    * Network-server name.
    */
    'name': string;
    /**
    * Network-server server. Format: hostname:ip (e.g. localhost:8000).
    */
    'server': string;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "server",
            "baseName": "server",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiNetworkServerListItem.attributeTypeMap;
    }
}

export class ApiOrganization {
    /**
    * Can the organization create and \"own\" Gateways?
    */
    'canHaveGateways': boolean;
    /**
    * Organization display name.
    */
    'displayName': string;
    /**
    * Organization ID.
    */
    'id': string;
    /**
    * Organization name.
    */
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canHaveGateways",
            "baseName": "canHaveGateways",
            "type": "boolean"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiOrganization.attributeTypeMap;
    }
}

/**
* Defines an organization to which an user is associated.
*/
export class ApiOrganizationLink {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * User is admin within the context of this organization.
    */
    'isAdmin': boolean;
    /**
    * Organization ID.
    */
    'organizationID': string;
    /**
    * Organization name.
    */
    'organizationName': string;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "organizationName",
            "baseName": "organizationName",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiOrganizationLink.attributeTypeMap;
    }
}

export class ApiOrganizationListItem {
    /**
    * Can the organization create and \"own\" Gateways?
    */
    'canHaveGateways': boolean;
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Organization display name.
    */
    'displayName': string;
    /**
    * Organization ID.
    */
    'id': string;
    /**
    * Organization name.
    */
    'name': string;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canHaveGateways",
            "baseName": "canHaveGateways",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiOrganizationListItem.attributeTypeMap;
    }
}

export class ApiOrganizationUser {
    /**
    * User is admin within the context of the organization.
    */
    'isAdmin': boolean;
    /**
    * Organization ID.
    */
    'organizationID': string;
    /**
    * User ID.
    */
    'userID': string;
    /**
    * Username (only used on get).
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "userID",
            "baseName": "userID",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiOrganizationUser.attributeTypeMap;
    }
}

export class ApiOrganizationUserListItem {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * User is admin within the context of the organization.
    */
    'isAdmin': boolean;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;
    /**
    * User ID.
    */
    'userID': string;
    /**
    * Username.
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        },
        {
            "name": "userID",
            "baseName": "userID",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiOrganizationUserListItem.attributeTypeMap;
    }
}

export class ApiPingRX {
    /**
    * Altitude of the gateway in meters.
    */
    'altitude': number;
    /**
    * Gateway ID (HEX encoded).
    */
    'gatewayID': string;
    /**
    * Latitude of the gateway -90.0 to 90.0.
    */
    'latitude': number;
    /**
    * LoRa SNR.
    */
    'loRaSNR': number;
    /**
    * Longitude of the gateway -180.0 to 180.0.
    */
    'longitude': number;
    /**
    * RSSI.
    */
    'rssi': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "altitude",
            "baseName": "altitude",
            "type": "number"
        },
        {
            "name": "gatewayID",
            "baseName": "gatewayID",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "loRaSNR",
            "baseName": "loRaSNR",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "rssi",
            "baseName": "rssi",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiPingRX.attributeTypeMap;
    }
}

export class ApiProfileResponse {
    /**
    * Organizations to which the user is associated.
    */
    'organizations': Array<ApiOrganizationLink>;
    /**
    * Profile settings.
    */
    'settings': ApiProfileSettings;
    /**
    * User object.
    */
    'user': ApiUser;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizations",
            "baseName": "organizations",
            "type": "Array<ApiOrganizationLink>"
        },
        {
            "name": "settings",
            "baseName": "settings",
            "type": "ApiProfileSettings"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ApiUser"
        }    ];

    static getAttributeTypeMap() {
        return ApiProfileResponse.attributeTypeMap;
    }
}

export class ApiProfileSettings {
    /**
    * Existing users in the system can not be assigned to organizations and application and can not be listed by non global admin users.
    */
    'disableAssignExistingUsers': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "disableAssignExistingUsers",
            "baseName": "disableAssignExistingUsers",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ApiProfileSettings.attributeTypeMap;
    }
}

/**
* - DROP: Drop  - MARK: Mark
*/
export class ApiRatePolicy {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ApiRatePolicy.attributeTypeMap;
    }
}

export class ApiServiceProfile {
    /**
    * GW metadata (RSSI, SNR, GW geoloc., etc.) are added to the packet sent to AS.
    */
    'addGWMetaData': boolean;
    /**
    * Channel mask. sNS does not have to obey (i.e., informative).
    */
    'channelMask': string;
    /**
    * Frequency to initiate an End-Device status request (request/day).
    */
    'devStatusReqFreq': number;
    /**
    * Token bucket burst size.
    */
    'dlBucketSize': number;
    /**
    * Token bucket filling rate, including ACKs (packet/h).
    */
    'dlRate': number;
    /**
    * Drop or mark when exceeding DLRate.
    */
    'dlRatePolicy': ApiRatePolicy;
    /**
    * Maximum allowed data rate. Used for ADR.
    */
    'drMax': number;
    /**
    * Minimum allowed data rate. Used for ADR.
    */
    'drMin': number;
    /**
    * Handover Roaming allowed.
    */
    'hrAllowed': boolean;
    /**
    * Service-profile ID (UUID string). This will be automatically set on create.
    */
    'id': string;
    /**
    * Minimum number of receiving GWs (informative).
    */
    'minGWDiversity': number;
    /**
    * Service-profile name.
    */
    'name': string;
    /**
    * Network-server ID on which the service-profile is provisioned.
    */
    'networkServerID': string;
    /**
    * Enable network geolocation service.
    */
    'nwkGeoLoc': boolean;
    /**
    * Organization ID to which the service-profile is assigned.
    */
    'organizationID': string;
    /**
    * Passive Roaming allowed.
    */
    'prAllowed': boolean;
    /**
    * Roaming Activation allowed.
    */
    'raAllowed': boolean;
    /**
    * Report End-Device battery level to AS.
    */
    'reportDevStatusBattery': boolean;
    /**
    * Report End-Device margin to AS.
    */
    'reportDevStatusMargin': boolean;
    /**
    * Target Packet Error Rate.
    */
    'targetPER': number;
    /**
    * Token bucket burst size.
    */
    'ulBucketSize': number;
    /**
    * Token bucket filling rate, including ACKs (packet/h).
    */
    'ulRate': number;
    /**
    * Drop or mark when exceeding ULRate.
    */
    'ulRatePolicy': ApiRatePolicy;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addGWMetaData",
            "baseName": "addGWMetaData",
            "type": "boolean"
        },
        {
            "name": "channelMask",
            "baseName": "channelMask",
            "type": "string"
        },
        {
            "name": "devStatusReqFreq",
            "baseName": "devStatusReqFreq",
            "type": "number"
        },
        {
            "name": "dlBucketSize",
            "baseName": "dlBucketSize",
            "type": "number"
        },
        {
            "name": "dlRate",
            "baseName": "dlRate",
            "type": "number"
        },
        {
            "name": "dlRatePolicy",
            "baseName": "dlRatePolicy",
            "type": "ApiRatePolicy"
        },
        {
            "name": "drMax",
            "baseName": "drMax",
            "type": "number"
        },
        {
            "name": "drMin",
            "baseName": "drMin",
            "type": "number"
        },
        {
            "name": "hrAllowed",
            "baseName": "hrAllowed",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "minGWDiversity",
            "baseName": "minGWDiversity",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "networkServerID",
            "baseName": "networkServerID",
            "type": "string"
        },
        {
            "name": "nwkGeoLoc",
            "baseName": "nwkGeoLoc",
            "type": "boolean"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "prAllowed",
            "baseName": "prAllowed",
            "type": "boolean"
        },
        {
            "name": "raAllowed",
            "baseName": "raAllowed",
            "type": "boolean"
        },
        {
            "name": "reportDevStatusBattery",
            "baseName": "reportDevStatusBattery",
            "type": "boolean"
        },
        {
            "name": "reportDevStatusMargin",
            "baseName": "reportDevStatusMargin",
            "type": "boolean"
        },
        {
            "name": "targetPER",
            "baseName": "targetPER",
            "type": "number"
        },
        {
            "name": "ulBucketSize",
            "baseName": "ulBucketSize",
            "type": "number"
        },
        {
            "name": "ulRate",
            "baseName": "ulRate",
            "type": "number"
        },
        {
            "name": "ulRatePolicy",
            "baseName": "ulRatePolicy",
            "type": "ApiRatePolicy"
        }    ];

    static getAttributeTypeMap() {
        return ApiServiceProfile.attributeTypeMap;
    }
}

export class ApiServiceProfileListItem {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * Service-profile ID (UUID string).
    */
    'id': string;
    /**
    * Service-profile name.
    */
    'name': string;
    /**
    * Network-server ID of the service-profile.
    */
    'networkServerID': string;
    /**
    * Organization ID of the service-profile.
    */
    'organizationID': string;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "networkServerID",
            "baseName": "networkServerID",
            "type": "string"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ApiServiceProfileListItem.attributeTypeMap;
    }
}

export class ApiStreamDeviceEventLogsResponse {
    /**
    * The event payload in JSON encoding.
    */
    'payloadJSON': string;
    /**
    * The event type.
    */
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payloadJSON",
            "baseName": "payloadJSON",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiStreamDeviceEventLogsResponse.attributeTypeMap;
    }
}

export class ApiStreamDeviceFrameLogsResponse {
    /**
    * Contains a downlink frame.
    */
    'downlinkFrame': ApiDownlinkFrameLog;
    /**
    * Contains an uplink frame.
    */
    'uplinkFrame': ApiUplinkFrameLog;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "downlinkFrame",
            "baseName": "downlinkFrame",
            "type": "ApiDownlinkFrameLog"
        },
        {
            "name": "uplinkFrame",
            "baseName": "uplinkFrame",
            "type": "ApiUplinkFrameLog"
        }    ];

    static getAttributeTypeMap() {
        return ApiStreamDeviceFrameLogsResponse.attributeTypeMap;
    }
}

export class ApiStreamGatewayFrameLogsResponse {
    /**
    * Contains a downlink frame.
    */
    'downlinkFrame': ApiDownlinkFrameLog;
    /**
    * Contains an uplink frame.
    */
    'uplinkFrame': ApiUplinkFrameLog;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "downlinkFrame",
            "baseName": "downlinkFrame",
            "type": "ApiDownlinkFrameLog"
        },
        {
            "name": "uplinkFrame",
            "baseName": "uplinkFrame",
            "type": "ApiUplinkFrameLog"
        }    ];

    static getAttributeTypeMap() {
        return ApiStreamGatewayFrameLogsResponse.attributeTypeMap;
    }
}

export class ApiUpdateApplicationRequest {
    /**
    * Application object to update.
    */
    'application': ApiApplication;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "application",
            "baseName": "application",
            "type": "ApiApplication"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateApplicationRequest.attributeTypeMap;
    }
}

export class ApiUpdateDeviceKeysRequest {
    /**
    * Device-keys object to update.
    */
    'deviceKeys': ApiDeviceKeys;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceKeys",
            "baseName": "deviceKeys",
            "type": "ApiDeviceKeys"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateDeviceKeysRequest.attributeTypeMap;
    }
}

export class ApiUpdateDeviceProfileRequest {
    /**
    * Device-profile object to update.
    */
    'deviceProfile': ApiDeviceProfile;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceProfile",
            "baseName": "deviceProfile",
            "type": "ApiDeviceProfile"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateDeviceProfileRequest.attributeTypeMap;
    }
}

export class ApiUpdateDeviceRequest {
    /**
    * Device object to update.
    */
    'device': ApiDevice;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "device",
            "baseName": "device",
            "type": "ApiDevice"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateDeviceRequest.attributeTypeMap;
    }
}

export class ApiUpdateGatewayProfileRequest {
    /**
    * Gateway-profile object to update.
    */
    'gatewayProfile': ApiGatewayProfile;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gatewayProfile",
            "baseName": "gatewayProfile",
            "type": "ApiGatewayProfile"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateGatewayProfileRequest.attributeTypeMap;
    }
}

export class ApiUpdateGatewayRequest {
    /**
    * Gateway object to update.
    */
    'gateway': ApiGateway;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "ApiGateway"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateGatewayRequest.attributeTypeMap;
    }
}

export class ApiUpdateHTTPIntegrationRequest {
    /**
    * Integration object to update.
    */
    'integration': ApiHTTPIntegration;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "integration",
            "baseName": "integration",
            "type": "ApiHTTPIntegration"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateHTTPIntegrationRequest.attributeTypeMap;
    }
}

export class ApiUpdateInfluxDBIntegrationRequest {
    /**
    * Integration object.
    */
    'integration': ApiInfluxDBIntegration;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "integration",
            "baseName": "integration",
            "type": "ApiInfluxDBIntegration"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateInfluxDBIntegrationRequest.attributeTypeMap;
    }
}

export class ApiUpdateMulticastGroupRequest {
    /**
    * Multicast-group object to update.
    */
    'multicastGroup': ApiMulticastGroup;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "multicastGroup",
            "baseName": "multicastGroup",
            "type": "ApiMulticastGroup"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateMulticastGroupRequest.attributeTypeMap;
    }
}

export class ApiUpdateNetworkServerRequest {
    /**
    * Network-server object to update.
    */
    'networkServer': ApiNetworkServer;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "networkServer",
            "baseName": "networkServer",
            "type": "ApiNetworkServer"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateNetworkServerRequest.attributeTypeMap;
    }
}

export class ApiUpdateOrganizationRequest {
    /**
    * Organization object to update.
    */
    'organization': ApiOrganization;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organization",
            "baseName": "organization",
            "type": "ApiOrganization"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateOrganizationRequest.attributeTypeMap;
    }
}

export class ApiUpdateOrganizationUserRequest {
    /**
    * Organization-user object to update.
    */
    'organizationUser': ApiOrganizationUser;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationUser",
            "baseName": "organizationUser",
            "type": "ApiOrganizationUser"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateOrganizationUserRequest.attributeTypeMap;
    }
}

export class ApiUpdateServiceProfileRequest {
    /**
    * Service-profile object to update.
    */
    'serviceProfile': ApiServiceProfile;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "serviceProfile",
            "baseName": "serviceProfile",
            "type": "ApiServiceProfile"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateServiceProfileRequest.attributeTypeMap;
    }
}

export class ApiUpdateUserPasswordRequest {
    /**
    * New pasword.
    */
    'password': string;
    /**
    * User ID.
    */
    'userId': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateUserPasswordRequest.attributeTypeMap;
    }
}

export class ApiUpdateUserRequest {
    /**
    * User object to update.
    */
    'user': ApiUser;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "ApiUser"
        }    ];

    static getAttributeTypeMap() {
        return ApiUpdateUserRequest.attributeTypeMap;
    }
}

export class ApiUplinkFrameLog {
    /**
    * LoRaWAN PHYPayload.
    */
    'phyPayloadJSON': string;
    /**
    * RX information of the uplink.
    */
    'rxInfo': Array<ApiUplinkRXInfo>;
    /**
    * TX information of the uplink.
    */
    'txInfo': GwUplinkTXInfo;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phyPayloadJSON",
            "baseName": "phyPayloadJSON",
            "type": "string"
        },
        {
            "name": "rxInfo",
            "baseName": "rxInfo",
            "type": "Array<ApiUplinkRXInfo>"
        },
        {
            "name": "txInfo",
            "baseName": "txInfo",
            "type": "GwUplinkTXInfo"
        }    ];

    static getAttributeTypeMap() {
        return ApiUplinkFrameLog.attributeTypeMap;
    }
}

/**
* This is a copy of gw.UplinkRXInfo with the only change that the gateway_id is of type string so that we can return it as HEX encoded instead of base64.
*/
export class ApiUplinkRXInfo {
    /**
    * Antenna.
    */
    'antenna': number;
    /**
    * Board.
    */
    'board': number;
    /**
    * Channel.
    */
    'channel': number;
    /**
    * Encrypted fine-timestamp data.
    */
    'encryptedFineTimestamp': ApiEncryptedFineTimestamp;
    /**
    * Fine-timestamp type.
    */
    'fineTimestampType': GwFineTimestampType;
    /**
    * Gateway ID.
    */
    'gatewayId': string;
    /**
    * Location.
    */
    'location': CommonLocation;
    /**
    * LoRa SNR.
    */
    'loraSnr': number;
    /**
    * Plain fine-timestamp data.
    */
    'plainFineTimestamp': GwPlainFineTimestamp;
    /**
    * RF Chain.
    */
    'rfChain': number;
    /**
    * RSSI.
    */
    'rssi': number;
    /**
    * RX time (only set when the gateway has a GPS module).
    */
    'time': Date;
    /**
    * RX time since GPS epoch (only set when the gateway has a GPS module).
    */
    'timeSinceGpsEpoch': string;
    /**
    * Gateway internal timestamp.
    */
    'timestamp': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "antenna",
            "baseName": "antenna",
            "type": "number"
        },
        {
            "name": "board",
            "baseName": "board",
            "type": "number"
        },
        {
            "name": "channel",
            "baseName": "channel",
            "type": "number"
        },
        {
            "name": "encryptedFineTimestamp",
            "baseName": "encryptedFineTimestamp",
            "type": "ApiEncryptedFineTimestamp"
        },
        {
            "name": "fineTimestampType",
            "baseName": "fineTimestampType",
            "type": "GwFineTimestampType"
        },
        {
            "name": "gatewayId",
            "baseName": "gatewayId",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "CommonLocation"
        },
        {
            "name": "loraSnr",
            "baseName": "loraSnr",
            "type": "number"
        },
        {
            "name": "plainFineTimestamp",
            "baseName": "plainFineTimestamp",
            "type": "GwPlainFineTimestamp"
        },
        {
            "name": "rfChain",
            "baseName": "rfChain",
            "type": "number"
        },
        {
            "name": "rssi",
            "baseName": "rssi",
            "type": "number"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        },
        {
            "name": "timeSinceGpsEpoch",
            "baseName": "timeSinceGpsEpoch",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiUplinkRXInfo.attributeTypeMap;
    }
}

export class ApiUser {
    /**
    * E-mail of the user.
    */
    'email': string;
    /**
    * User ID. Will be set automatically on create.
    */
    'id': string;
    /**
    * Set to false to disable the user.
    */
    'isActive': boolean;
    /**
    * Set to true to make the user a global administrator.
    */
    'isAdmin': boolean;
    /**
    * Optional note to store with the user.
    */
    'note': string;
    /**
    * The session timeout, in minutes.
    */
    'sessionTTL': number;
    /**
    * Username of the user.
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "sessionTTL",
            "baseName": "sessionTTL",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiUser.attributeTypeMap;
    }
}

export class ApiUserListItem {
    /**
    * Created at timestamp.
    */
    'createdAt': Date;
    /**
    * E-mail of the user.
    */
    'email': string;
    /**
    * User ID. Will be set automatically on create.
    */
    'id': string;
    /**
    * Set to false to disable the user.
    */
    'isActive': boolean;
    /**
    * Set to true to make the user a global administrator.
    */
    'isAdmin': boolean;
    /**
    * Optional note to store with the user.
    */
    'note': string;
    /**
    * The session timeout, in minutes.
    */
    'sessionTTL': number;
    /**
    * Last update timestamp.
    */
    'updatedAt': Date;
    /**
    * Username of the user.
    */
    'username': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "createdAt",
            "type": "Date"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "isActive",
            "type": "boolean"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "sessionTTL",
            "baseName": "sessionTTL",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updatedAt",
            "type": "Date"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiUserListItem.attributeTypeMap;
    }
}

export class ApiUserOrganization {
    /**
    * User has admin rights within the organization.
    */
    'isAdmin': boolean;
    /**
    * Organization ID.
    */
    'organizationID': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "organizationID",
            "baseName": "organizationID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiUserOrganization.attributeTypeMap;
    }
}

export class CommonLocation {
    /**
    * Accuracy (in meters).
    */
    'accuracy': number;
    /**
    * Altitude.
    */
    'altitude': number;
    /**
    * Latitude.
    */
    'latitude': number;
    /**
    * Longitude.
    */
    'longitude': number;
    /**
    * Location source.
    */
    'source': CommonLocationSource;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accuracy",
            "baseName": "accuracy",
            "type": "number"
        },
        {
            "name": "altitude",
            "baseName": "altitude",
            "type": "number"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "CommonLocationSource"
        }    ];

    static getAttributeTypeMap() {
        return CommonLocation.attributeTypeMap;
    }
}

/**
*  - UNKNOWN: Unknown.  - GPS: GPS.  - CONFIG: Manually configured.  - GEO_RESOLVER: Geo resolver.
*/
export class CommonLocationSource {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CommonLocationSource.attributeTypeMap;
    }
}

/**
* - LORA: LoRa  - FSK: FSK
*/
export class CommonModulation {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CommonModulation.attributeTypeMap;
    }
}

export class GwFSKModulationInfo {
    /**
    * Bandwidth.
    */
    'bandwidth': number;
    /**
    * Bitrate.
    */
    'bitrate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bandwidth",
            "baseName": "bandwidth",
            "type": "number"
        },
        {
            "name": "bitrate",
            "baseName": "bitrate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GwFSKModulationInfo.attributeTypeMap;
    }
}

/**
*  - NONE: No fine-timestamp available.  - ENCRYPTED: Encrypted fine-timestamp.  - PLAIN: Plain fine-timestamp.
*/
export class GwFineTimestampType {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GwFineTimestampType.attributeTypeMap;
    }
}

export class GwLoRaModulationInfo {
    /**
    * Bandwidth.
    */
    'bandwidth': number;
    /**
    * Code-rate.
    */
    'codeRate': string;
    /**
    * Polarization inversion.
    */
    'polarizationInversion': boolean;
    /**
    * Speading-factor.
    */
    'spreadingFactor': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bandwidth",
            "baseName": "bandwidth",
            "type": "number"
        },
        {
            "name": "codeRate",
            "baseName": "codeRate",
            "type": "string"
        },
        {
            "name": "polarizationInversion",
            "baseName": "polarizationInversion",
            "type": "boolean"
        },
        {
            "name": "spreadingFactor",
            "baseName": "spreadingFactor",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GwLoRaModulationInfo.attributeTypeMap;
    }
}

export class GwPlainFineTimestamp {
    /**
    * Full timestamp.
    */
    'time': Date;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return GwPlainFineTimestamp.attributeTypeMap;
    }
}

export class GwUplinkTXInfo {
    /**
    * Frequency (Hz).
    */
    'frequency': number;
    /**
    * FSK modulation information.
    */
    'fskModulationInfo': GwFSKModulationInfo;
    /**
    * LoRa modulation information.
    */
    'loRaModulationInfo': GwLoRaModulationInfo;
    /**
    * Modulation.
    */
    'modulation': CommonModulation;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "fskModulationInfo",
            "baseName": "fskModulationInfo",
            "type": "GwFSKModulationInfo"
        },
        {
            "name": "loRaModulationInfo",
            "baseName": "loRaModulationInfo",
            "type": "GwLoRaModulationInfo"
        },
        {
            "name": "modulation",
            "baseName": "modulation",
            "type": "CommonModulation"
        }    ];

    static getAttributeTypeMap() {
        return GwUplinkTXInfo.attributeTypeMap;
    }
}

/**
* A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance:
*/
export class ProtobufEmpty {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ProtobufEmpty.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "ApiActivateDeviceRequest": ApiActivateDeviceRequest,
    "ApiAddDeviceToMulticastGroupRequest": ApiAddDeviceToMulticastGroupRequest,
    "ApiAddOrganizationUserRequest": ApiAddOrganizationUserRequest,
    "ApiApplication": ApiApplication,
    "ApiApplicationListItem": ApiApplicationListItem,
    "ApiBrandingResponse": ApiBrandingResponse,
    "ApiCreateApplicationRequest": ApiCreateApplicationRequest,
    "ApiCreateApplicationResponse": ApiCreateApplicationResponse,
    "ApiCreateDeviceKeysRequest": ApiCreateDeviceKeysRequest,
    "ApiCreateDeviceProfileRequest": ApiCreateDeviceProfileRequest,
    "ApiCreateDeviceProfileResponse": ApiCreateDeviceProfileResponse,
    "ApiCreateDeviceRequest": ApiCreateDeviceRequest,
    "ApiCreateGatewayProfileRequest": ApiCreateGatewayProfileRequest,
    "ApiCreateGatewayProfileResponse": ApiCreateGatewayProfileResponse,
    "ApiCreateGatewayRequest": ApiCreateGatewayRequest,
    "ApiCreateHTTPIntegrationRequest": ApiCreateHTTPIntegrationRequest,
    "ApiCreateInfluxDBIntegrationRequest": ApiCreateInfluxDBIntegrationRequest,
    "ApiCreateMulticastGroupRequest": ApiCreateMulticastGroupRequest,
    "ApiCreateMulticastGroupResponse": ApiCreateMulticastGroupResponse,
    "ApiCreateNetworkServerRequest": ApiCreateNetworkServerRequest,
    "ApiCreateNetworkServerResponse": ApiCreateNetworkServerResponse,
    "ApiCreateOrganizationRequest": ApiCreateOrganizationRequest,
    "ApiCreateOrganizationResponse": ApiCreateOrganizationResponse,
    "ApiCreateServiceProfileRequest": ApiCreateServiceProfileRequest,
    "ApiCreateServiceProfileResponse": ApiCreateServiceProfileResponse,
    "ApiCreateUserRequest": ApiCreateUserRequest,
    "ApiCreateUserResponse": ApiCreateUserResponse,
    "ApiDevice": ApiDevice,
    "ApiDeviceActivation": ApiDeviceActivation,
    "ApiDeviceKeys": ApiDeviceKeys,
    "ApiDeviceListItem": ApiDeviceListItem,
    "ApiDeviceProfile": ApiDeviceProfile,
    "ApiDeviceProfileListItem": ApiDeviceProfileListItem,
    "ApiDeviceQueueItem": ApiDeviceQueueItem,
    "ApiDownlinkFrameLog": ApiDownlinkFrameLog,
    "ApiDownlinkTXInfo": ApiDownlinkTXInfo,
    "ApiEncryptedFineTimestamp": ApiEncryptedFineTimestamp,
    "ApiEnqueueDeviceQueueItemRequest": ApiEnqueueDeviceQueueItemRequest,
    "ApiEnqueueDeviceQueueItemResponse": ApiEnqueueDeviceQueueItemResponse,
    "ApiEnqueueMulticastQueueItemRequest": ApiEnqueueMulticastQueueItemRequest,
    "ApiEnqueueMulticastQueueItemResponse": ApiEnqueueMulticastQueueItemResponse,
    "ApiGateway": ApiGateway,
    "ApiGatewayBoard": ApiGatewayBoard,
    "ApiGatewayListItem": ApiGatewayListItem,
    "ApiGatewayProfile": ApiGatewayProfile,
    "ApiGatewayProfileExtraChannel": ApiGatewayProfileExtraChannel,
    "ApiGatewayProfileListItem": ApiGatewayProfileListItem,
    "ApiGatewayStats": ApiGatewayStats,
    "ApiGetApplicationResponse": ApiGetApplicationResponse,
    "ApiGetDeviceActivationResponse": ApiGetDeviceActivationResponse,
    "ApiGetDeviceKeysResponse": ApiGetDeviceKeysResponse,
    "ApiGetDeviceProfileResponse": ApiGetDeviceProfileResponse,
    "ApiGetDeviceResponse": ApiGetDeviceResponse,
    "ApiGetGatewayProfileResponse": ApiGetGatewayProfileResponse,
    "ApiGetGatewayResponse": ApiGetGatewayResponse,
    "ApiGetGatewayStatsResponse": ApiGetGatewayStatsResponse,
    "ApiGetHTTPIntegrationResponse": ApiGetHTTPIntegrationResponse,
    "ApiGetInfluxDBIntegrationResponse": ApiGetInfluxDBIntegrationResponse,
    "ApiGetLastPingResponse": ApiGetLastPingResponse,
    "ApiGetMulticastGroupResponse": ApiGetMulticastGroupResponse,
    "ApiGetNetworkServerResponse": ApiGetNetworkServerResponse,
    "ApiGetOrganizationResponse": ApiGetOrganizationResponse,
    "ApiGetOrganizationUserResponse": ApiGetOrganizationUserResponse,
    "ApiGetRandomDevAddrResponse": ApiGetRandomDevAddrResponse,
    "ApiGetServiceProfileResponse": ApiGetServiceProfileResponse,
    "ApiGetUserResponse": ApiGetUserResponse,
    "ApiGlobalSearchResponse": ApiGlobalSearchResponse,
    "ApiGlobalSearchResult": ApiGlobalSearchResult,
    "ApiHTTPIntegration": ApiHTTPIntegration,
    "ApiHTTPIntegrationHeader": ApiHTTPIntegrationHeader,
    "ApiInfluxDBIntegration": ApiInfluxDBIntegration,
    "ApiInfluxDBPrecision": ApiInfluxDBPrecision,
    "ApiIntegrationKind": ApiIntegrationKind,
    "ApiIntegrationListItem": ApiIntegrationListItem,
    "ApiListApplicationResponse": ApiListApplicationResponse,
    "ApiListDeviceProfileResponse": ApiListDeviceProfileResponse,
    "ApiListDeviceQueueItemsResponse": ApiListDeviceQueueItemsResponse,
    "ApiListDeviceResponse": ApiListDeviceResponse,
    "ApiListGatewayProfilesResponse": ApiListGatewayProfilesResponse,
    "ApiListGatewayResponse": ApiListGatewayResponse,
    "ApiListIntegrationResponse": ApiListIntegrationResponse,
    "ApiListMulticastGroupQueueItemsResponse": ApiListMulticastGroupQueueItemsResponse,
    "ApiListMulticastGroupResponse": ApiListMulticastGroupResponse,
    "ApiListNetworkServerResponse": ApiListNetworkServerResponse,
    "ApiListOrganizationResponse": ApiListOrganizationResponse,
    "ApiListOrganizationUsersResponse": ApiListOrganizationUsersResponse,
    "ApiListServiceProfileResponse": ApiListServiceProfileResponse,
    "ApiListUserResponse": ApiListUserResponse,
    "ApiLoginRequest": ApiLoginRequest,
    "ApiLoginResponse": ApiLoginResponse,
    "ApiMulticastGroup": ApiMulticastGroup,
    "ApiMulticastGroupListItem": ApiMulticastGroupListItem,
    "ApiMulticastGroupType": ApiMulticastGroupType,
    "ApiMulticastQueueItem": ApiMulticastQueueItem,
    "ApiNetworkServer": ApiNetworkServer,
    "ApiNetworkServerListItem": ApiNetworkServerListItem,
    "ApiOrganization": ApiOrganization,
    "ApiOrganizationLink": ApiOrganizationLink,
    "ApiOrganizationListItem": ApiOrganizationListItem,
    "ApiOrganizationUser": ApiOrganizationUser,
    "ApiOrganizationUserListItem": ApiOrganizationUserListItem,
    "ApiPingRX": ApiPingRX,
    "ApiProfileResponse": ApiProfileResponse,
    "ApiProfileSettings": ApiProfileSettings,
    "ApiRatePolicy": ApiRatePolicy,
    "ApiServiceProfile": ApiServiceProfile,
    "ApiServiceProfileListItem": ApiServiceProfileListItem,
    "ApiStreamDeviceEventLogsResponse": ApiStreamDeviceEventLogsResponse,
    "ApiStreamDeviceFrameLogsResponse": ApiStreamDeviceFrameLogsResponse,
    "ApiStreamGatewayFrameLogsResponse": ApiStreamGatewayFrameLogsResponse,
    "ApiUpdateApplicationRequest": ApiUpdateApplicationRequest,
    "ApiUpdateDeviceKeysRequest": ApiUpdateDeviceKeysRequest,
    "ApiUpdateDeviceProfileRequest": ApiUpdateDeviceProfileRequest,
    "ApiUpdateDeviceRequest": ApiUpdateDeviceRequest,
    "ApiUpdateGatewayProfileRequest": ApiUpdateGatewayProfileRequest,
    "ApiUpdateGatewayRequest": ApiUpdateGatewayRequest,
    "ApiUpdateHTTPIntegrationRequest": ApiUpdateHTTPIntegrationRequest,
    "ApiUpdateInfluxDBIntegrationRequest": ApiUpdateInfluxDBIntegrationRequest,
    "ApiUpdateMulticastGroupRequest": ApiUpdateMulticastGroupRequest,
    "ApiUpdateNetworkServerRequest": ApiUpdateNetworkServerRequest,
    "ApiUpdateOrganizationRequest": ApiUpdateOrganizationRequest,
    "ApiUpdateOrganizationUserRequest": ApiUpdateOrganizationUserRequest,
    "ApiUpdateServiceProfileRequest": ApiUpdateServiceProfileRequest,
    "ApiUpdateUserPasswordRequest": ApiUpdateUserPasswordRequest,
    "ApiUpdateUserRequest": ApiUpdateUserRequest,
    "ApiUplinkFrameLog": ApiUplinkFrameLog,
    "ApiUplinkRXInfo": ApiUplinkRXInfo,
    "ApiUser": ApiUser,
    "ApiUserListItem": ApiUserListItem,
    "ApiUserOrganization": ApiUserOrganization,
    "CommonLocation": CommonLocation,
    "CommonLocationSource": CommonLocationSource,
    "CommonModulation": CommonModulation,
    "GwFSKModulationInfo": GwFSKModulationInfo,
    "GwFineTimestampType": GwFineTimestampType,
    "GwLoRaModulationInfo": GwLoRaModulationInfo,
    "GwPlainFineTimestamp": GwPlainFineTimestamp,
    "GwUplinkTXInfo": GwUplinkTXInfo,
    "ProtobufEmpty": ProtobufEmpty,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ApplicationServiceApiApiKeys {
}

export class ApplicationServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApplicationServiceApiApiKeys, value: string) {
        (this.authentications as any)[ApplicationServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete deletes the given application.
     * @param id Application ID.
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/applications/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create creates the given application.
     * @param body 
     */
    public create (body: ApiCreateApplicationRequest) : Promise<{ response: http.ClientResponse; body: ApiCreateApplicationResponse;  }> {
        const localVarPath = this.basePath + '/api/applications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateApplicationRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCreateApplicationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCreateApplicationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary CreateHTTPIntegration creates a HTTP application-integration.
     * @param integrationApplicationId The id of the application.
     * @param body 
     */
    public createHTTPIntegration (integrationApplicationId: string, body: ApiCreateHTTPIntegrationRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/applications/{integration.application_id}/integrations/http'
            .replace('{' + 'integration.application_id' + '}', encodeURIComponent(String(integrationApplicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationApplicationId' is not null or undefined
        if (integrationApplicationId === null || integrationApplicationId === undefined) {
            throw new Error('Required parameter integrationApplicationId was null or undefined when calling createHTTPIntegration.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createHTTPIntegration.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateHTTPIntegrationRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary CreateInfluxDBIntegration create an InfluxDB application-integration.
     * @param integrationApplicationId Application ID.
     * @param body 
     */
    public createInfluxDBIntegration (integrationApplicationId: string, body: ApiCreateInfluxDBIntegrationRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/applications/{integration.application_id}/integrations/influxdb'
            .replace('{' + 'integration.application_id' + '}', encodeURIComponent(String(integrationApplicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationApplicationId' is not null or undefined
        if (integrationApplicationId === null || integrationApplicationId === undefined) {
            throw new Error('Required parameter integrationApplicationId was null or undefined when calling createInfluxDBIntegration.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createInfluxDBIntegration.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateInfluxDBIntegrationRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary DeleteIntegration deletes the HTTP application-integration.
     * @param applicationId The id of the application.
     */
    public deleteHTTPIntegration (applicationId: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/applications/{application_id}/integrations/http'
            .replace('{' + 'application_id' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling deleteHTTPIntegration.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary DeleteInfluxDBIntegration deletes the InfluxDB application-integration.
     * @param applicationId Application ID.
     */
    public deleteInfluxDBIntegration (applicationId: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/applications/{application_id}/integrations/influxdb'
            .replace('{' + 'application_id' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling deleteInfluxDBIntegration.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get returns the requested application.
     * @param id Application ID.
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetApplicationResponse;  }> {
        const localVarPath = this.basePath + '/api/applications/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetApplicationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetApplicationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary GetHTTPIntegration returns the HTTP application-integration.
     * @param applicationId Application ID.
     */
    public getHTTPIntegration (applicationId: string) : Promise<{ response: http.ClientResponse; body: ApiGetHTTPIntegrationResponse;  }> {
        const localVarPath = this.basePath + '/api/applications/{application_id}/integrations/http'
            .replace('{' + 'application_id' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getHTTPIntegration.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetHTTPIntegrationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetHTTPIntegrationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary GetInfluxDBIntegration returns the InfluxDB application-integration.
     * @param applicationId Application ID.
     */
    public getInfluxDBIntegration (applicationId: string) : Promise<{ response: http.ClientResponse; body: ApiGetInfluxDBIntegrationResponse;  }> {
        const localVarPath = this.basePath + '/api/applications/{application_id}/integrations/influxdb'
            .replace('{' + 'application_id' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getInfluxDBIntegration.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetInfluxDBIntegrationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetInfluxDBIntegrationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List lists the available applications.
     * @param limit Max number of applications to return in the result-test.
     * @param offset Offset in the result-set (for pagination).
     * @param organizationID ID of the organization to filter on.
     * @param search Search on name (optional).
     */
    public list (limit?: string, offset?: string, organizationID?: string, search?: string) : Promise<{ response: http.ClientResponse; body: ApiListApplicationResponse;  }> {
        const localVarPath = this.basePath + '/api/applications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (organizationID !== undefined) {
            localVarQueryParameters['organizationID'] = ObjectSerializer.serialize(organizationID, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListApplicationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListApplicationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary ListIntegrations lists all configured integrations.
     * @param applicationId The id of the application.
     */
    public listIntegrations (applicationId: string) : Promise<{ response: http.ClientResponse; body: ApiListIntegrationResponse;  }> {
        const localVarPath = this.basePath + '/api/applications/{application_id}/integrations'
            .replace('{' + 'application_id' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling listIntegrations.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListIntegrationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListIntegrationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update updates the given application.
     * @param applicationId Application ID. This will be automatically assigned on create.
     * @param body 
     */
    public update (applicationId: string, body: ApiUpdateApplicationRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/applications/{application.id}'
            .replace('{' + 'application.id' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateApplicationRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UpdateHTTPIntegration updates the HTTP application-integration.
     * @param integrationApplicationId The id of the application.
     * @param body 
     */
    public updateHTTPIntegration (integrationApplicationId: string, body: ApiUpdateHTTPIntegrationRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/applications/{integration.application_id}/integrations/http'
            .replace('{' + 'integration.application_id' + '}', encodeURIComponent(String(integrationApplicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationApplicationId' is not null or undefined
        if (integrationApplicationId === null || integrationApplicationId === undefined) {
            throw new Error('Required parameter integrationApplicationId was null or undefined when calling updateHTTPIntegration.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateHTTPIntegration.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateHTTPIntegrationRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UpdateInfluxDBIntegration updates the InfluxDB application-integration.
     * @param integrationApplicationId Application ID.
     * @param body 
     */
    public updateInfluxDBIntegration (integrationApplicationId: string, body: ApiUpdateInfluxDBIntegrationRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/applications/{integration.application_id}/integrations/influxdb'
            .replace('{' + 'integration.application_id' + '}', encodeURIComponent(String(integrationApplicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'integrationApplicationId' is not null or undefined
        if (integrationApplicationId === null || integrationApplicationId === undefined) {
            throw new Error('Required parameter integrationApplicationId was null or undefined when calling updateInfluxDBIntegration.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateInfluxDBIntegration.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateInfluxDBIntegrationRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceProfileServiceApiApiKeys {
}

export class DeviceProfileServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeviceProfileServiceApiApiKeys, value: string) {
        (this.authentications as any)[DeviceProfileServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete deletes the device-profile matching the given id.
     * @param id Device-profile ID (UUID string).
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/device-profiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create creates the given device-profile.
     * @param body 
     */
    public create (body: ApiCreateDeviceProfileRequest) : Promise<{ response: http.ClientResponse; body: ApiCreateDeviceProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/device-profiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateDeviceProfileRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCreateDeviceProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCreateDeviceProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get returns the device-profile matching the given id.
     * @param id Device-profile ID (UUID string).
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetDeviceProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/device-profiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetDeviceProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetDeviceProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List lists the available device-profiles.
     * @param limit Max number of items to return.
     * @param offset Offset in the result-set (for pagination).
     * @param organizationID Organization id to filter on.
     * @param applicationID Application id to filter on.
     */
    public list (limit?: string, offset?: string, organizationID?: string, applicationID?: string) : Promise<{ response: http.ClientResponse; body: ApiListDeviceProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/device-profiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (organizationID !== undefined) {
            localVarQueryParameters['organizationID'] = ObjectSerializer.serialize(organizationID, "string");
        }

        if (applicationID !== undefined) {
            localVarQueryParameters['applicationID'] = ObjectSerializer.serialize(applicationID, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListDeviceProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListDeviceProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update updates the given device-profile.
     * @param deviceProfileId Device-profile ID (UUID string).
     * @param body 
     */
    public update (deviceProfileId: string, body: ApiUpdateDeviceProfileRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/device-profiles/{device_profile.id}'
            .replace('{' + 'device_profile.id' + '}', encodeURIComponent(String(deviceProfileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceProfileId' is not null or undefined
        if (deviceProfileId === null || deviceProfileId === undefined) {
            throw new Error('Required parameter deviceProfileId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateDeviceProfileRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceQueueServiceApiApiKeys {
}

export class DeviceQueueServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeviceQueueServiceApiApiKeys, value: string) {
        (this.authentications as any)[DeviceQueueServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Enqueue adds the given item to the device-queue.
     * @param deviceQueueItemDevEui Device EUI (HEX encoded).
     * @param body 
     */
    public enqueue (deviceQueueItemDevEui: string, body: ApiEnqueueDeviceQueueItemRequest) : Promise<{ response: http.ClientResponse; body: ApiEnqueueDeviceQueueItemResponse;  }> {
        const localVarPath = this.basePath + '/api/devices/{device_queue_item.dev_eui}/queue'
            .replace('{' + 'device_queue_item.dev_eui' + '}', encodeURIComponent(String(deviceQueueItemDevEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceQueueItemDevEui' is not null or undefined
        if (deviceQueueItemDevEui === null || deviceQueueItemDevEui === undefined) {
            throw new Error('Required parameter deviceQueueItemDevEui was null or undefined when calling enqueue.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling enqueue.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiEnqueueDeviceQueueItemRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiEnqueueDeviceQueueItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiEnqueueDeviceQueueItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Flush flushes the downlink device-queue.
     * @param devEui Device EUI (HEX encoded).
     */
    public flush (devEui: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}/queue'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling flush.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List lists the items in the device-queue.
     * @param devEui Device EUI (HEX encoded).
     */
    public list (devEui: string) : Promise<{ response: http.ClientResponse; body: ApiListDeviceQueueItemsResponse;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}/queue'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling list.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListDeviceQueueItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListDeviceQueueItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceServiceApiApiKeys {
}

export class DeviceServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeviceServiceApiApiKeys, value: string) {
        (this.authentications as any)[DeviceServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete deletes the device matching the given DevEUI.
     * @param devEui Device EUI (HEX encoded).
     */
    public _delete (devEui: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Activate (re)activates the device (only when ABP is set to true).
     * @param deviceActivationDevEui Device EUI (HEX encoded).
     * @param body 
     */
    public activate (deviceActivationDevEui: string, body: ApiActivateDeviceRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/devices/{device_activation.dev_eui}/activate'
            .replace('{' + 'device_activation.dev_eui' + '}', encodeURIComponent(String(deviceActivationDevEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceActivationDevEui' is not null or undefined
        if (deviceActivationDevEui === null || deviceActivationDevEui === undefined) {
            throw new Error('Required parameter deviceActivationDevEui was null or undefined when calling activate.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling activate.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiActivateDeviceRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create creates the given device.
     * @param body 
     */
    public create (body: ApiCreateDeviceRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/devices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateDeviceRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary CreateKeys creates the given device-keys.
     * @param deviceKeysDevEui Device EUI (HEX encoded).
     * @param body 
     */
    public createKeys (deviceKeysDevEui: string, body: ApiCreateDeviceKeysRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/devices/{device_keys.dev_eui}/keys'
            .replace('{' + 'device_keys.dev_eui' + '}', encodeURIComponent(String(deviceKeysDevEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceKeysDevEui' is not null or undefined
        if (deviceKeysDevEui === null || deviceKeysDevEui === undefined) {
            throw new Error('Required parameter deviceKeysDevEui was null or undefined when calling createKeys.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createKeys.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateDeviceKeysRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary DeleteKeys deletes the device-keys for the given DevEUI.
     * @param devEui Device EUI (HEX encoded).
     */
    public deleteKeys (devEui: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}/keys'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling deleteKeys.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get returns the device matching the given DevEUI.
     * @param devEui Device EUI (HEX encoded).
     */
    public get (devEui: string) : Promise<{ response: http.ClientResponse; body: ApiGetDeviceResponse;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetDeviceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetDeviceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary GetActivation returns the current activation details of the device (OTAA and ABP).
     * @param devEui Device EUI (HEX encoded).
     */
    public getActivation (devEui: string) : Promise<{ response: http.ClientResponse; body: ApiGetDeviceActivationResponse;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}/activation'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling getActivation.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetDeviceActivationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetDeviceActivationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary GetKeys returns the device-keys for the given DevEUI.
     * @param devEui Device EUI (HEX encoded).
     */
    public getKeys (devEui: string) : Promise<{ response: http.ClientResponse; body: ApiGetDeviceKeysResponse;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}/keys'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling getKeys.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetDeviceKeysResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetDeviceKeysResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary GetRandomDevAddr returns a random DevAddr taking the NwkID prefix into account.
     * @param devEui Device EUI (HEX encoded).
     */
    public getRandomDevAddr (devEui: string) : Promise<{ response: http.ClientResponse; body: ApiGetRandomDevAddrResponse;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}/getRandomDevAddr'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling getRandomDevAddr.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetRandomDevAddrResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetRandomDevAddrResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List returns the available devices.
     * @param limit Max number of devices to return in the result-set.
     * @param offset Offset in the result-set (for pagination).
     * @param applicationID Application ID to filter on.
     * @param search Search on name or DevEUI.
     * @param multicastGroupID Multicast-group ID to filter on (string formatted UUID).
     * @param serviceProfileID Service-profile ID to filter on (string formatted UUID).
     */
    public list (limit?: string, offset?: string, applicationID?: string, search?: string, multicastGroupID?: string, serviceProfileID?: string) : Promise<{ response: http.ClientResponse; body: ApiListDeviceResponse;  }> {
        const localVarPath = this.basePath + '/api/devices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (applicationID !== undefined) {
            localVarQueryParameters['applicationID'] = ObjectSerializer.serialize(applicationID, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (multicastGroupID !== undefined) {
            localVarQueryParameters['multicastGroupID'] = ObjectSerializer.serialize(multicastGroupID, "string");
        }

        if (serviceProfileID !== undefined) {
            localVarQueryParameters['serviceProfileID'] = ObjectSerializer.serialize(serviceProfileID, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListDeviceResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListDeviceResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary StreamEventLogs stream the device events (uplink payloads, ACKs, joins, errors).   * This endpoint is intended for debugging only.   * This endpoint does not work from a web-browser.
     * @param devEui Device EUI (HEX encoded).
     */
    public streamEventLogs (devEui: string) : Promise<{ response: http.ClientResponse; body: ApiStreamDeviceEventLogsResponse;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}/events'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling streamEventLogs.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiStreamDeviceEventLogsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiStreamDeviceEventLogsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary StreamFrameLogs streams the uplink and downlink frame-logs for the given DevEUI.   * These are the raw LoRaWAN frames and this endpoint is intended for debugging only.   * This endpoint does not work from a web-browser.
     * @param devEui Device EUI (HEX encoded).
     */
    public streamFrameLogs (devEui: string) : Promise<{ response: http.ClientResponse; body: ApiStreamDeviceFrameLogsResponse;  }> {
        const localVarPath = this.basePath + '/api/devices/{dev_eui}/frames'
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling streamFrameLogs.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiStreamDeviceFrameLogsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiStreamDeviceFrameLogsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update updates the device matching the given DevEUI.
     * @param deviceDevEui Device EUI (HEX encoded).
     * @param body 
     */
    public update (deviceDevEui: string, body: ApiUpdateDeviceRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/devices/{device.dev_eui}'
            .replace('{' + 'device.dev_eui' + '}', encodeURIComponent(String(deviceDevEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceDevEui' is not null or undefined
        if (deviceDevEui === null || deviceDevEui === undefined) {
            throw new Error('Required parameter deviceDevEui was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateDeviceRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UpdateKeys updates the device-keys.
     * @param deviceKeysDevEui Device EUI (HEX encoded).
     * @param body 
     */
    public updateKeys (deviceKeysDevEui: string, body: ApiUpdateDeviceKeysRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/devices/{device_keys.dev_eui}/keys'
            .replace('{' + 'device_keys.dev_eui' + '}', encodeURIComponent(String(deviceKeysDevEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceKeysDevEui' is not null or undefined
        if (deviceKeysDevEui === null || deviceKeysDevEui === undefined) {
            throw new Error('Required parameter deviceKeysDevEui was null or undefined when calling updateKeys.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateKeys.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateDeviceKeysRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GatewayProfileServiceApiApiKeys {
}

export class GatewayProfileServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GatewayProfileServiceApiApiKeys, value: string) {
        (this.authentications as any)[GatewayProfileServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete deletes the gateway-profile matching the given id.
     * @param id Gateway-profile id (UUID string).
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/gateway-profiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create creates the given gateway-profile.
     * @param body 
     */
    public create (body: ApiCreateGatewayProfileRequest) : Promise<{ response: http.ClientResponse; body: ApiCreateGatewayProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/gateway-profiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateGatewayProfileRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCreateGatewayProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCreateGatewayProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get returns the gateway-profile matching the given id.
     * @param id Gateway-profile ID (UUID string).
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetGatewayProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/gateway-profiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetGatewayProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetGatewayProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List returns the existing gateway-profiles.
     * @param limit Max number of items to return.
     * @param offset Offset in the result-set (for pagination).
     * @param networkServerID Network-server ID to filter on (optional).
     */
    public list (limit?: string, offset?: string, networkServerID?: string) : Promise<{ response: http.ClientResponse; body: ApiListGatewayProfilesResponse;  }> {
        const localVarPath = this.basePath + '/api/gateway-profiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (networkServerID !== undefined) {
            localVarQueryParameters['networkServerID'] = ObjectSerializer.serialize(networkServerID, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListGatewayProfilesResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListGatewayProfilesResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update updates the given gateway-profile.
     * @param gatewayProfileId Gateway-profile ID (UUID string).
     * @param body 
     */
    public update (gatewayProfileId: string, body: ApiUpdateGatewayProfileRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/gateway-profiles/{gateway_profile.id}'
            .replace('{' + 'gateway_profile.id' + '}', encodeURIComponent(String(gatewayProfileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'gatewayProfileId' is not null or undefined
        if (gatewayProfileId === null || gatewayProfileId === undefined) {
            throw new Error('Required parameter gatewayProfileId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateGatewayProfileRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GatewayServiceApiApiKeys {
}

export class GatewayServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GatewayServiceApiApiKeys, value: string) {
        (this.authentications as any)[GatewayServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete deletes the gateway matching the given mac address.
     * @param id Gateway ID (HEX encoded).
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/gateways/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create creates the given gateway.
     * @param body 
     */
    public create (body: ApiCreateGatewayRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/gateways';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateGatewayRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get returns the gateway for the requested mac address.
     * @param id Gateway ID (HEX encoded).
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetGatewayResponse;  }> {
        const localVarPath = this.basePath + '/api/gateways/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetGatewayResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetGatewayResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary GetLastPing returns the last emitted ping and gateways receiving this ping.
     * @param gatewayId Gateway ID (HEX encoded).
     */
    public getLastPing (gatewayId: string) : Promise<{ response: http.ClientResponse; body: ApiGetLastPingResponse;  }> {
        const localVarPath = this.basePath + '/api/gateways/{gateway_id}/pings/last'
            .replace('{' + 'gateway_id' + '}', encodeURIComponent(String(gatewayId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getLastPing.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetLastPingResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetLastPingResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary GetStats lists the gateway stats given the query parameters.
     * @param gatewayId Gateway ID (HEX encoded).
     * @param interval Aggregation interval.  One of \&quot;second\&quot;, \&quot;minute\&quot;, \&quot;hour\&quot;, \&quot;day\&quot;, \&quot;week\&quot;, \&quot;month\&quot;, \&quot;quarter\&quot;, \&quot;year\&quot;.  Case insensitive.
     * @param startTimestamp Timestamp to start from.
     * @param endTimestamp Timestamp until to get from.
     */
    public getStats (gatewayId: string, interval?: string, startTimestamp?: Date, endTimestamp?: Date) : Promise<{ response: http.ClientResponse; body: ApiGetGatewayStatsResponse;  }> {
        const localVarPath = this.basePath + '/api/gateways/{gateway_id}/stats'
            .replace('{' + 'gateway_id' + '}', encodeURIComponent(String(gatewayId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling getStats.');
        }

        if (interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(interval, "string");
        }

        if (startTimestamp !== undefined) {
            localVarQueryParameters['startTimestamp'] = ObjectSerializer.serialize(startTimestamp, "Date");
        }

        if (endTimestamp !== undefined) {
            localVarQueryParameters['endTimestamp'] = ObjectSerializer.serialize(endTimestamp, "Date");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetGatewayStatsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetGatewayStatsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List lists the gateways.
     * @param limit Max number of nodes to return in the result-set.
     * @param offset Offset of the result-set (for pagination).
     * @param organizationID ID of the organization for which to filter on, when left blank the response will return all gateways to which the user has access to.
     * @param search Search on name or gateway MAC (optional).
     */
    public list (limit?: number, offset?: number, organizationID?: string, search?: string) : Promise<{ response: http.ClientResponse; body: ApiListGatewayResponse;  }> {
        const localVarPath = this.basePath + '/api/gateways';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (organizationID !== undefined) {
            localVarQueryParameters['organizationID'] = ObjectSerializer.serialize(organizationID, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListGatewayResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListGatewayResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary StreamFrameLogs streams the uplink and downlink frame-logs for the given gateway ID. Notes:   * These are the raw LoRaWAN frames and this endpoint is intended for debugging only.   * This endpoint does not work from a web-browser.
     * @param gatewayId Gateway ID (HEX encoded).
     */
    public streamFrameLogs (gatewayId: string) : Promise<{ response: http.ClientResponse; body: ApiStreamGatewayFrameLogsResponse;  }> {
        const localVarPath = this.basePath + '/api/gateways/{gateway_id}/frames'
            .replace('{' + 'gateway_id' + '}', encodeURIComponent(String(gatewayId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling streamFrameLogs.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiStreamGatewayFrameLogsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiStreamGatewayFrameLogsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update updates the gateway matching the given mac address.
     * @param gatewayId Gateway ID (HEX encoded).
     * @param body 
     */
    public update (gatewayId: string, body: ApiUpdateGatewayRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/gateways/{gateway.id}'
            .replace('{' + 'gateway.id' + '}', encodeURIComponent(String(gatewayId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'gatewayId' is not null or undefined
        if (gatewayId === null || gatewayId === undefined) {
            throw new Error('Required parameter gatewayId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateGatewayRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InternalServiceApiApiKeys {
}

export class InternalServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InternalServiceApiApiKeys, value: string) {
        (this.authentications as any)[InternalServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the branding for the UI
     */
    public branding () : Promise<{ response: http.ClientResponse; body: ApiBrandingResponse;  }> {
        const localVarPath = this.basePath + '/api/internal/branding';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiBrandingResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiBrandingResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Perform a global search.
     * @param search Search query.
     * @param limit Max number of results to return.
     * @param offset Offset offset of the result-set (for pagination).
     */
    public globalSearch (search?: string, limit?: string, offset?: string) : Promise<{ response: http.ClientResponse; body: ApiGlobalSearchResponse;  }> {
        const localVarPath = this.basePath + '/api/internal/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGlobalSearchResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGlobalSearchResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Log in a user
     * @param body 
     */
    public login (body: ApiLoginRequest) : Promise<{ response: http.ClientResponse; body: ApiLoginResponse;  }> {
        const localVarPath = this.basePath + '/api/internal/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling login.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiLoginRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiLoginResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiLoginResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the current user's profile
     */
    public profile () : Promise<{ response: http.ClientResponse; body: ApiProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/internal/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MulticastGroupServiceApiApiKeys {
}

export class MulticastGroupServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MulticastGroupServiceApiApiKeys, value: string) {
        (this.authentications as any)[MulticastGroupServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete deletes a multicast-group given an ID.
     * @param id ID (string formatted UUID).
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary AddDevice adds the given device to the multicast-group.
     * @param multicastGroupId Multicast-group ID (string formatted UUID).
     * @param body 
     */
    public addDevice (multicastGroupId: string, body: ApiAddDeviceToMulticastGroupRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups/{multicast_group_id}/devices'
            .replace('{' + 'multicast_group_id' + '}', encodeURIComponent(String(multicastGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'multicastGroupId' is not null or undefined
        if (multicastGroupId === null || multicastGroupId === undefined) {
            throw new Error('Required parameter multicastGroupId was null or undefined when calling addDevice.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addDevice.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiAddDeviceToMulticastGroupRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create creates the given multicast-group.
     * @param body 
     */
    public create (body: ApiCreateMulticastGroupRequest) : Promise<{ response: http.ClientResponse; body: ApiCreateMulticastGroupResponse;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateMulticastGroupRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCreateMulticastGroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCreateMulticastGroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Enqueue adds the given item to the multicast-queue.
     * @param multicastQueueItemMulticastGroupId Multicast-group ID (string formatted UUID).
     * @param body 
     */
    public enqueue (multicastQueueItemMulticastGroupId: string, body: ApiEnqueueMulticastQueueItemRequest) : Promise<{ response: http.ClientResponse; body: ApiEnqueueMulticastQueueItemResponse;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups/{multicast_queue_item.multicast_group_id}/queue'
            .replace('{' + 'multicast_queue_item.multicast_group_id' + '}', encodeURIComponent(String(multicastQueueItemMulticastGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'multicastQueueItemMulticastGroupId' is not null or undefined
        if (multicastQueueItemMulticastGroupId === null || multicastQueueItemMulticastGroupId === undefined) {
            throw new Error('Required parameter multicastQueueItemMulticastGroupId was null or undefined when calling enqueue.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling enqueue.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiEnqueueMulticastQueueItemRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiEnqueueMulticastQueueItemResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiEnqueueMulticastQueueItemResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary FlushQueue flushes the multicast-group queue.
     * @param multicastGroupId Multicast-group ID (string formatted UUID).
     */
    public flushQueue (multicastGroupId: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups/{multicast_group_id}/queue'
            .replace('{' + 'multicast_group_id' + '}', encodeURIComponent(String(multicastGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'multicastGroupId' is not null or undefined
        if (multicastGroupId === null || multicastGroupId === undefined) {
            throw new Error('Required parameter multicastGroupId was null or undefined when calling flushQueue.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get returns a multicast-group given an ID.
     * @param id ID (string formatted UUID).
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetMulticastGroupResponse;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetMulticastGroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetMulticastGroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List lists the available multicast-groups.
     * @param limit Max number of items to return.
     * @param offset Offset in the result-set (for pagination).
     * @param organizationID Organization id to filter on.
     * @param devEUI Device EUI (HEX encoded string) to filter on.
     * @param serviceProfileID Service-profile ID to filter on.
     * @param search Search can be used to search on the multicast-group name.
     */
    public list (limit?: string, offset?: string, organizationID?: string, devEUI?: string, serviceProfileID?: string, search?: string) : Promise<{ response: http.ClientResponse; body: ApiListMulticastGroupResponse;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (organizationID !== undefined) {
            localVarQueryParameters['organizationID'] = ObjectSerializer.serialize(organizationID, "string");
        }

        if (devEUI !== undefined) {
            localVarQueryParameters['devEUI'] = ObjectSerializer.serialize(devEUI, "string");
        }

        if (serviceProfileID !== undefined) {
            localVarQueryParameters['serviceProfileID'] = ObjectSerializer.serialize(serviceProfileID, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListMulticastGroupResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListMulticastGroupResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary ListQueue lists the items in the multicast-group queue.
     * @param multicastGroupId Multicast-group ID (string formatted UUID).
     */
    public listQueue (multicastGroupId: string) : Promise<{ response: http.ClientResponse; body: ApiListMulticastGroupQueueItemsResponse;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups/{multicast_group_id}/queue'
            .replace('{' + 'multicast_group_id' + '}', encodeURIComponent(String(multicastGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'multicastGroupId' is not null or undefined
        if (multicastGroupId === null || multicastGroupId === undefined) {
            throw new Error('Required parameter multicastGroupId was null or undefined when calling listQueue.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListMulticastGroupQueueItemsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListMulticastGroupQueueItemsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary RemoveDevice removes the given device from the multicast-group.
     * @param multicastGroupId Multicast-group ID (string formatted UUID).
     * @param devEui Device EUI (HEX encoded string).
     */
    public removeDevice (multicastGroupId: string, devEui: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups/{multicast_group_id}/devices/{dev_eui}'
            .replace('{' + 'multicast_group_id' + '}', encodeURIComponent(String(multicastGroupId)))
            .replace('{' + 'dev_eui' + '}', encodeURIComponent(String(devEui)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'multicastGroupId' is not null or undefined
        if (multicastGroupId === null || multicastGroupId === undefined) {
            throw new Error('Required parameter multicastGroupId was null or undefined when calling removeDevice.');
        }

        // verify required parameter 'devEui' is not null or undefined
        if (devEui === null || devEui === undefined) {
            throw new Error('Required parameter devEui was null or undefined when calling removeDevice.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update updates the given multicast-group.
     * @param multicastGroupId ID (string formatted UUID). This will be generated automatically on create.
     * @param body 
     */
    public update (multicastGroupId: string, body: ApiUpdateMulticastGroupRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/multicast-groups/{multicast_group.id}'
            .replace('{' + 'multicast_group.id' + '}', encodeURIComponent(String(multicastGroupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'multicastGroupId' is not null or undefined
        if (multicastGroupId === null || multicastGroupId === undefined) {
            throw new Error('Required parameter multicastGroupId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateMulticastGroupRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NetworkServerServiceApiApiKeys {
}

export class NetworkServerServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NetworkServerServiceApiApiKeys, value: string) {
        (this.authentications as any)[NetworkServerServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete deletes the network-server matching the given id.
     * @param id Network-server ID.
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/network-servers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create creates the given network-server.
     * @param body 
     */
    public create (body: ApiCreateNetworkServerRequest) : Promise<{ response: http.ClientResponse; body: ApiCreateNetworkServerResponse;  }> {
        const localVarPath = this.basePath + '/api/network-servers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateNetworkServerRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCreateNetworkServerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCreateNetworkServerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get returns the network-server matching the given id.
     * @param id Network-server ID.
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetNetworkServerResponse;  }> {
        const localVarPath = this.basePath + '/api/network-servers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetNetworkServerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetNetworkServerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List lists the available network-servers.
     * @param limit Max number of items to return.
     * @param offset Offset in the result-set (for pagination).
     * @param organizationID Organization id to filter on.
     */
    public list (limit?: string, offset?: string, organizationID?: string) : Promise<{ response: http.ClientResponse; body: ApiListNetworkServerResponse;  }> {
        const localVarPath = this.basePath + '/api/network-servers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (organizationID !== undefined) {
            localVarQueryParameters['organizationID'] = ObjectSerializer.serialize(organizationID, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListNetworkServerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListNetworkServerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update updates the given network-server.
     * @param networkServerId Network-server ID.
     * @param body 
     */
    public update (networkServerId: string, body: ApiUpdateNetworkServerRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/network-servers/{network_server.id}'
            .replace('{' + 'network_server.id' + '}', encodeURIComponent(String(networkServerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'networkServerId' is not null or undefined
        if (networkServerId === null || networkServerId === undefined) {
            throw new Error('Required parameter networkServerId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateNetworkServerRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationServiceApiApiKeys {
}

export class OrganizationServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationServiceApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete an organization.
     * @param id Organization ID.
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/organizations/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a new user to an organization.
     * @param organizationUserOrganizationId Organization ID.
     * @param body 
     */
    public addUser (organizationUserOrganizationId: string, body: ApiAddOrganizationUserRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/organizations/{organization_user.organization_id}/users'
            .replace('{' + 'organization_user.organization_id' + '}', encodeURIComponent(String(organizationUserOrganizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationUserOrganizationId' is not null or undefined
        if (organizationUserOrganizationId === null || organizationUserOrganizationId === undefined) {
            throw new Error('Required parameter organizationUserOrganizationId was null or undefined when calling addUser.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiAddOrganizationUserRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new organization.
     * @param body 
     */
    public create (body: ApiCreateOrganizationRequest) : Promise<{ response: http.ClientResponse; body: ApiCreateOrganizationResponse;  }> {
        const localVarPath = this.basePath + '/api/organizations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateOrganizationRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCreateOrganizationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCreateOrganizationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a user from an organization.
     * @param organizationId Organization ID.
     * @param userId User ID.
     */
    public deleteUser (organizationId: string, userId: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/organizations/{organization_id}/users/{user_id}'
            .replace('{' + 'organization_id' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling deleteUser.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get data for a particular organization.
     * @param id Organization ID.
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetOrganizationResponse;  }> {
        const localVarPath = this.basePath + '/api/organizations/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetOrganizationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetOrganizationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get data for a particular organization user.
     * @param organizationId Organization ID.
     * @param userId User ID.
     */
    public getUser (organizationId: string, userId: string) : Promise<{ response: http.ClientResponse; body: ApiGetOrganizationUserResponse;  }> {
        const localVarPath = this.basePath + '/api/organizations/{organization_id}/users/{user_id}'
            .replace('{' + 'organization_id' + '}', encodeURIComponent(String(organizationId)))
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getUser.');
        }

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetOrganizationUserResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetOrganizationUserResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get organization list.
     * @param limit Max number of organizations to return in the result-set.
     * @param offset Offset in the result-set (for pagination).
     * @param search When provided, the given string will be used to search on displayName.
     */
    public list (limit?: string, offset?: string, search?: string) : Promise<{ response: http.ClientResponse; body: ApiListOrganizationResponse;  }> {
        const localVarPath = this.basePath + '/api/organizations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListOrganizationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListOrganizationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get organization's user list.
     * @param organizationId Organization ID.
     * @param limit Max number of users to return in the result-set.
     * @param offset Offset in the result-set (for pagination).
     */
    public listUsers (organizationId: string, limit?: number, offset?: number) : Promise<{ response: http.ClientResponse; body: ApiListOrganizationUsersResponse;  }> {
        const localVarPath = this.basePath + '/api/organizations/{organization_id}/users'
            .replace('{' + 'organization_id' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling listUsers.');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListOrganizationUsersResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListOrganizationUsersResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an existing organization.
     * @param organizationId Organization ID.
     * @param body 
     */
    public update (organizationId: string, body: ApiUpdateOrganizationRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/organizations/{organization.id}'
            .replace('{' + 'organization.id' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateOrganizationRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a user in an organization.
     * @param organizationUserOrganizationId Organization ID.
     * @param organizationUserUserId User ID.
     * @param body 
     */
    public updateUser (organizationUserOrganizationId: string, organizationUserUserId: string, body: ApiUpdateOrganizationUserRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/organizations/{organization_user.organization_id}/users/{organization_user.user_id}'
            .replace('{' + 'organization_user.organization_id' + '}', encodeURIComponent(String(organizationUserOrganizationId)))
            .replace('{' + 'organization_user.user_id' + '}', encodeURIComponent(String(organizationUserUserId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationUserOrganizationId' is not null or undefined
        if (organizationUserOrganizationId === null || organizationUserOrganizationId === undefined) {
            throw new Error('Required parameter organizationUserOrganizationId was null or undefined when calling updateUser.');
        }

        // verify required parameter 'organizationUserUserId' is not null or undefined
        if (organizationUserUserId === null || organizationUserUserId === undefined) {
            throw new Error('Required parameter organizationUserUserId was null or undefined when calling updateUser.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateOrganizationUserRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServiceProfileServiceApiApiKeys {
}

export class ServiceProfileServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ServiceProfileServiceApiApiKeys, value: string) {
        (this.authentications as any)[ServiceProfileServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete deletes the service-profile matching the given id.
     * @param id Service-profile ID (UUID string).
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/service-profiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create creates the given service-profile.
     * @param body 
     */
    public create (body: ApiCreateServiceProfileRequest) : Promise<{ response: http.ClientResponse; body: ApiCreateServiceProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/service-profiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateServiceProfileRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCreateServiceProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCreateServiceProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get returns the service-profile matching the given id.
     * @param id Service-profile ID (UUID string).
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetServiceProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/service-profiles/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetServiceProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetServiceProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List lists the available service-profiles.
     * @param limit Max number of items to return.
     * @param offset Offset in the result-set (for pagination).
     * @param organizationID Organization id to filter on.
     */
    public list (limit?: string, offset?: string, organizationID?: string) : Promise<{ response: http.ClientResponse; body: ApiListServiceProfileResponse;  }> {
        const localVarPath = this.basePath + '/api/service-profiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (organizationID !== undefined) {
            localVarQueryParameters['organizationID'] = ObjectSerializer.serialize(organizationID, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListServiceProfileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListServiceProfileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update updates the given serviceprofile.
     * @param serviceProfileId Service-profile ID (UUID string). This will be automatically set on create.
     * @param body 
     */
    public update (serviceProfileId: string, body: ApiUpdateServiceProfileRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/service-profiles/{service_profile.id}'
            .replace('{' + 'service_profile.id' + '}', encodeURIComponent(String(serviceProfileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serviceProfileId' is not null or undefined
        if (serviceProfileId === null || serviceProfileId === undefined) {
            throw new Error('Required parameter serviceProfileId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateServiceProfileRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserServiceApiApiKeys {
}

export class UserServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserServiceApiApiKeys, value: string) {
        (this.authentications as any)[UserServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a user.
     * @param id User ID.
     */
    public _delete (id: string) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/users/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling _delete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new user.
     * @param body 
     */
    public create (body: ApiCreateUserRequest) : Promise<{ response: http.ClientResponse; body: ApiCreateUserResponse;  }> {
        const localVarPath = this.basePath + '/api/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiCreateUserRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiCreateUserResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiCreateUserResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get data for a particular user.
     * @param id User ID.
     */
    public get (id: string) : Promise<{ response: http.ClientResponse; body: ApiGetUserResponse;  }> {
        const localVarPath = this.basePath + '/api/users/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiGetUserResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiGetUserResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user list.
     * @param limit Max number of user to return in the result-set.
     * @param offset Offset in the result-set (for pagination).
     * @param search When provided, the given string will be used to search on username.
     */
    public list (limit?: string, offset?: string, search?: string) : Promise<{ response: http.ClientResponse; body: ApiListUserResponse;  }> {
        const localVarPath = this.basePath + '/api/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "string");
        }

        if (search !== undefined) {
            localVarQueryParameters['search'] = ObjectSerializer.serialize(search, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ApiListUserResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiListUserResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update an existing user.
     * @param userId User ID. Will be set automatically on create.
     * @param body 
     */
    public update (userId: string, body: ApiUpdateUserRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/users/{user.id}'
            .replace('{' + 'user.id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateUserRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary UpdatePassword updates a password.
     * @param userId User ID.
     * @param body 
     */
    public updatePassword (userId: string, body: ApiUpdateUserPasswordRequest) : Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }> {
        const localVarPath = this.basePath + '/api/users/{user_id}/password'
            .replace('{' + 'user_id' + '}', encodeURIComponent(String(userId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updatePassword.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePassword.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ApiUpdateUserPasswordRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProtobufEmpty;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProtobufEmpty");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
